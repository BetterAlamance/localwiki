= Notes =

== FileFields ==
  * Right now we simply block delete() on FileFields.  Django's default behavior
    is to never override a file -- it simply renames it whatever_2.txt. This
    will work for us, for now.

      * This will work for our (localwiki) purposes because we'll probably
        have a separate model for the actual file and we can have a long
        name attribute on it to mask the lame_name_45.jpg from the end user.

  * MAYBE: We may want to create a custom storage system that does other nice
    things like creates magic nested directories to hold files to avoid
    having 400,000 files in a single directory.  So when we deal with
    this we can look at doing fancy things.

    But with modern filesystems (e.g. ext4) the number of files per
    directory -- as long as they're accessed directly -- may not be a concern.

    So our dumb approach will probably work!

== Unique fields ==
We try do our best to be smart about unique fields! For instance, if you delete and then recreate a model (so it has a new integer primary key), we'll still pull up the correct history of the model based on its unique fields.

However, if you rename a unique field on a model you'll notice that it will clear out the history of the model unless there was a model with that same field in the past (in which case you'll see that model's history). If you'd like to rename all the historical versions' unique fields you'll want to do that by hand, kinda like this:

# assume 'name' is a unique field
p.name = "New name!"
for p_h in p.history.all():
    p_h.name = "New name!"
    p_h.save(track_changes=False)
p.save()

== Bulk QuerySet update() / Admin bulk actions ==
django-trackchanges works fine with QuerySet.delete() and the admin's bulk deleting.  However, at the moment there's no way to have it work with QuerySet.update().  We recommend not using QuerySet.update() on models you want to perserve versioning information on.

Working around this is braindead-easy!  See http://code.trac.localwiki.org/ticket/33 for a workaround.  Issuing a QuerySet.update() won't break anything -- it just won't save a new version of the model in the history.

For more information, see Django ticket #12184 (http://code.djangoproject.com/ticket/12184), #10754 (http://code.djangoproject.com/ticket/10754) and our ticket #33 (http://code.trac.localwiki.org/ticket/33).  Weigh in!

= Todo =

1: admin integration

before 'release':

explain why to use.

"Why not django-reversion or django-versions?"

Both of these apps serialize models into blobs.  We believe that having the full power of the Django ORM available is the best way to do this.  For lots of reasons:  you have the full power of the orm, migrations are easier and it's possible to do the sort of things we want to do - sorting, displaying, limiting of revisions.

"Why not django-revisions?"

==================================
==================================

-------
FOR OUR REAL TODO FILE (e.g. AFTER OUR INITIAL DEV):

3. admin interface - wait on this (after basic release). just leave it as a todo.
   ** VERY IMPORTANT ** SHOULD DO
   - look at how other similar projects are doing admin integration
   - we can mostly study the django-reversion code here
   - two sides:
      * logging info for actions taken via admin
      * viewing all changes for tracked-changes models in admin
   - look at django 1.1 change history thing in admin - a "History" button appears when viewing a model
      - called the django admin log
      - http://127.0.0.1:8000/admin/pagecms/page/11/history/
      - we should probably just over-ride this / hook into this on trackchanges models

= Uninteresting developer notes =
  * If we wanted to support something like real time editing with logging of all
    the incremental edits, we could form a "bundle" of these real-time edits
    that exists between concrete saves.  We could create a new model to store
    real-time only data and attach it to each concrete save.
