 * get related stuff working for foreignkey
 * onetoone fields
 * manytomany
 * wiki app using trackchanges
 * documentation
 * admin interface

= Notes =

== FileFields ==
  * Right now we simply block delete() on FileFields.  Django's default behavior
    is to never override a file -- it simply renames it whatever_2.txt. This
    will work for us, for now.

      * This will work for our (localwiki) purposes because we'll probably
        have a separate model for the actual file and we can have a long
        name attribute on it to mask the lame_name_45.jpg from the end user.

  * MAYBE: We may want to create a custom storage system that does other nice
    things like creates magic nested directories to hold files to avoid
    having 400,000 files in a single directory.  So when we deal with
    this we can look at doing fancy things.

    But with modern filesystems (e.g. ext4) the number of files per
    directory -- as long as they're accessed directly -- may not be a concern.

    So our dumb approach will probably work!

== Unique fields ==
We try do our best to be smart about unique fields! For instance, if you delete and then recreate a model (so it has a new integer primary key), we'll still pull up the correct history of the model based on its unique fields.

However, if you rename a unique field on a model you'll notice that it will clear out the history of the model unless there was a model with that same field in the past (in which case you'll see that model's history). If you'd like to rename all the historical versions' unique fields you'll want to do that by hand, kinda like this:

# assume 'name' is a unique field
p.name = "New name!"
for p_h in p.history.all():
    p_h.name = "New name!"
    p_h.save(track_changes=False)
p.save()

= Todo =

-1: ForeignKey lookup stuff.  maybe like:

"both reverse and direct, e.g., ForeignKey, ManyToManyField, and reverse relationships those create." -- "reverse relationships those create" => make this work.

 - ONLY figure it out on a lookup.
 - flag in TrackChanges() constructor.  default is on.
 - h.history_meta.object should return something that o.user is the old user on
 - if this is annoying down the road, change it.  for now it's a sane default.

0: admin integration

before 'release':

explain why to use.

"Why not django-reversion or django-versions?"

Both of these apps serialize models into blobs.  We believe that having the full power of the Django ORM available is the best way to do this.  For lots of reasons:  you have the full power of the orm, migrations are easier and it's possible to do the sort of things we want to do - sorting, displaying, limiting of revisions.

==================================
==================================

0.5.

 * how do we handle foreignkeys?
   * NOTE * this is for following relationships - a lookup.  We shouldn't automatically
            track changes on related models, at least not now.  In the future maybe we'll
            allow a follow flag.

    * The version datetime will suffice for tying versioned models together.
       -- XXX TODO: add a unique_together field to the historical model that
                    includes the history_date to ensure consistency here.

  -- i think we should have a nice way of dealing w/ foreignkeys when the key'ed object is also a versionedmodel
  -- otherwise we can't do much
  -- when it is versioned?:

    Imagine a Page-- it will have a page.files

      which is either File: .. ForeignKey(Page)..
                   or Page: ... files = ManyToManyField(Files)

    obviously, this can all be handled by hand by looking up the version of the 
    foreignkey object that's nearest (date wise) to the object at hand.

      * can automate (on/off via a flag) -- maybe m.history.auto_foreign_key...

     --- investigate and implement this

     check out what django-reversion does w/ follow_relationships()


document fully.  explain how to over-ride get_extra_fields (p 284 prodjango).
   * also make sure to explain that many of the methods are for convience
     - almost everything can be done via query sets!  m.history.filter()...
   * write sphinx documentation?

-------
FOR OUR REAL TODO FILE (e.g. AFTER OUR INITIAL DEV):

3. admin interface - wait on this (after basic release). just leave it as a todo.
   ** VERY IMPORTANT ** SHOULD DO
   - look at how other similar projects are doing admin integration
   - we can mostly study the django-reversion code here
   - two sides:
      * logging info for actions taken via admin
      * viewing all changes for tracked-changes models in admin
   - look at django 1.1 change history thing in admin - a "History" button appears when viewing a model
      - called the django admin log
      - http://127.0.0.1:8000/admin/pagecms/page/11/history/
      - we should probably just over-ride this / hook into this on trackchanges models

= Uninteresting developer notes =
  * If we wanted to support something like real time editing with logging of all
    the incremental edits, we could form a "bundle" of these real-time edits
    that exists between concrete saves.  We could create a new model to store
    real-time only data and attach it to each concrete save.
