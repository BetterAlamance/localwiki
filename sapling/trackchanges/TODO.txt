= Notes =

== FileFields ==
  * Right now we simply block delete() on FileFields.  Django's default behavior
    is to never override a file -- it simply renames it whatever_2.txt. This
    will work for us, for now.

      * This will work for our (localwiki) purposes because we'll probably
        have a separate model for the actual file and we can have a long
        name attribute on it to mask the lame_name_45.jpg from the end user.

  * MAYBE: We may want to create a custom storage system that does other nice
    things like creates magic nested directories to hold files to avoid
    having 400,000 files in a single directory.  So when we deal with
    this we can look at doing fancy things.

    But with modern filesystems (e.g. ext4) the number of files per
    directory -- as long as they're accessed directly -- may not be a concern.

    So our dumb approach will probably work!

= Todo =

-2: revert, delete in between, no revision tests.  reverts should be logged differently than ~

-1: ForeignKey lookup stuff.  maybe like:

 - ONLY figure it out on a lookup.
 - flag in TrackChanges() constructor.  default is on.
 - h.history_meta.object should return something that o.user is the old user on
 - if this is annoying down the road, change it.  for now it's a sane default.
----------------

0. Full API like modelhistory has.
   X * option to not track change for save
       o.history.track_changes = False
   * revert to version - directly implement?

    v = o.history.filter(..)
    m = v.history_meta.object
    m.save()

    let's do: 
    v.revert_to()

  [later] * we should log a revert differently than
     a delete, a change, an addition.

   X * revert to and delete newer versions:

      v = o.history.filter(...)
      v.revert_to(delete_newer_versions=True)

      * delete newer versions:

            delete newer versions w/o logging:
            3  | [3, 2, 1]  ->  2 | [2 , 1]

            with logging:
            3  | [3, 2, 1]  ->  2 | [2, 2, 1]

      * delete_newer_versions
      * delete_all - no need to implement this here, done by doing
        simple for v in o.history.all(): delete v
        
      * track_changes = False is 'dont log'
        -- so we manage this at the implementation level

      * don't log current save (?) ('dont log in RC')
      * delete all in-between

   X * get version number of an object
        v.history_meta.version_number

        to get version by #:

            try:
                v.history.all()[n]
            except IndexError:
                ...

        v.history_meta.get_version_number()

   X * as_of by version number

==================================
==================================

0. docstrings say "history.get()- what do i mean here"

 - malcolm says: managers good place for 'all objects / model as object rather than instance of object'
                 object methods good for acting on individual objects


0.5.  track_changes = False should be allowed to be sent in at the history = TrackChanges(auto_track=False) level.

general cleanup - '-' / '+' / '~' should be named and set as choices a'la modelhistory

 * how do we handle foreignkeys?
   * NOTE * this is for following relationships - a lookup.  We shouldn't automatically
            track changes on related models, at least not now.  In the future maybe we'll
            allow a follow flag.

    * The version datetime will suffice for tying versioned models together.
       -- XXX TODO: add a unique_together field to the historical model that
                    includes the history_date to ensure consistency here.

  -- i think we should have a nice way of dealing w/ foreignkeys when the key'ed object is also a versionedmodel
  -- otherwise we can't do much
  -- when it is versioned?:

    Imagine a Page-- it will have a page.files

      which is either File: .. ForeignKey(Page)..
                   or Page: ... files = ManyToManyField(Files)

    obviously, this can all be handled by hand by looking up the version of the 
    foreignkey object that's nearest (date wise) to the object at hand.

      * can automate (on/off via a flag) -- maybe m.history.auto_foreign_key...

     --- investigate and implement this

     check out what django-reversion does w/ follow_relationships()


document fully.  explain how to over-ride get_extra_fields (p 284 prodjango).
   * also make sure to explain that many of the methods are for convience
     - almost everything can be done via query sets!  m.history.filter()...
   * write sphinx documentation?

-------
FOR OUR REAL TODO FILE (e.g. AFTER OUR INITIAL DEV):

3. admin interface - wait on this (after basic release). just leave it as a todo.
   ** VERY IMPORTANT ** SHOULD DO
   - look at how other similar projects are doing admin integration
   - we need to grab the current user, ip, etc
     - don't use currentuserfield() approach - instead find a way to patch
       the admin directly
         ( this is what django-reversion does )
   - we can mostly study the django-reversion code here
   - two sides:
      * logging info for actions taken via admin
      * viewing all changes for tracked-changes models in admin
   - look at django 1.1 change history thing in admin - a "History" button appears when viewing a model
      - called the django admin log
      - http://127.0.0.1:8000/admin/pagecms/page/11/history/
      - we should probably just over-ride this / hook into this on trackchanges models

4. flag reverts differently than normal changes.  keep track of the version
   from which we reverted -- by revision id (? - global or per-page ) or 
   date?

= Uninteresting developer notes =
  * If we wanted to support something like real time editing with logging of all
    the incremental edits, we could form a "bundle" of these real-time edits
    that exists between concrete saves.  We could create a new model to store
    real-time only data and attach it to each concrete save.
