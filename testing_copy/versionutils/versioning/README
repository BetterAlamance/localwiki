===========================
``versionutils.versioning``
===========================

``django-versionutils``' ``versioning`` app is a smart and flexible versioning system for models.  Existing model versioning systems left much to be desired.  Major advantages over existing versioning systems are:

* Easy-to-use ORM access to historical model data.
* Supports relational fields and is *smart* about relational
  lookups.
* Stores model data in separate tables, one table for each versioned
  model.  Doesn't add book-keeping fields or crazy things to your models.
* Does not serialize model data.  Migrations aren't insane.
* Does smart lookup of old model versions, even if the model is
  currently deleted.  Tracks models by unique fields where possible.
* Easy to extend and add your own custom fields to versioned models.
* Supports several constructs important to real-world usage, like 
  "delete all newer versions when reverting" and "don't track changes for
  this save."  Allows per-save data, like a changeset comment, to be
  optionally passed into the parent model.
* Extensive test suite.
* Can optionally automatically track user information during saves.

How to Install
==============

First, add this project to your list of ``INSTALLED_APPS`` in
``settings.py``::

    INSTALLED_APPS = (
        'django.contrib.admin',
        'django.contrib.auth',
        'django.contrib.contenttypes',
        'django.contrib.sessions',
        'django.contrib.sites',
        ...
        'versiontutils.versioning',
        ...
    )

If you want to automatically track user information during saves, simply add
``AutoTrackUserInfoMiddleware`` to your middleware::

    MIDDLEWARE_CLASSES = (
        'django.middleware.common.CommonMiddleware',
        'django.contrib.sessions.middleware.SessionMiddleware',
        'django.contrib.auth.middleware.AuthenticationMiddleware',
        'versionutils.versioning.middleware.AutoTrackUserInfoMiddleware',
    )

Now you've got the app installed!  But you probably want to track changes on
some models, right?  Simply add ``TrackChanges()`` to a model you want to
version::

    from versionutils.versioning import TrackChanges
    
    class MyModel(models.Model):
        ...
    
        history = TrackChanges()

Then run ``manage.py syncdb`` and you're set!

Tutorial
========

Using ``versionutils.versioning`` is extremely simple.  Here's a little usage example to get you started::

    >>> m = Person(name="Philip", description="Some dude")
    >>> m.save()
    # Save again with a new description.
    >>> m.description = "Just some guy"
    >>> m.save()
    # Look up the first historical version.
    >>> m_hist = m.history.as_of(version=1)
    >>> m_hist
    <Person_hist: Person object as of 2011-02-15 17:23:20.483243>
    # The historical object has all the same attributes
    # as the original object.
    >>> m_hist.name
    u'Philip'
    >>> m_hist.description
    u'Some dude'

The historical object has information about the version, too::

    >>> m_hist.history_info.date
    datetime.datetime(2011, 2, 15, 17, 23, 20, 483243)
    >>> m_hist.history_info.version_number()
    1

If you enable the ``AutoTrackUserInfoMiddleware`` then the optional
``history_info.user`` and ``history_info.user_ip`` attributes be
automatically added.

You can add extra history fields to ``history_info`` by subclassing
``TrackChanges`` and extending the ``get_extra_history_fields`` method.

Reverting objects
-----------------

Super-easy!  All you need to do is call ``revert_to()`` on the historical
instance.

>>> m.description
u'Just some guy'
>>> m_hist = m.history.as_of(version=1)
>>> m_hist
<Person_hist: Person object as of 2011-02-15 17:23:20.483243>
>>> m_hist.revert_to()
>>> m = Person.objects.get(name="Philip")
>>> m.description
u'Some dude'

Getting historical objects
--------------------------

Sometimes we just want the most recent historical instance.  Calling
``history.most_recent()`` will do the trick:

>>> m.history.most_recent()
<Person_hist: Person object as of 2011-02-15 23:48:09.507812>

We've seen ``as_of()`` already.  ``as_of()`` can also take a ``date``
parameter:

>>> m.history.as_of(date=datetime(2011, 2, 15, 17, 23, 20, 483243))
<Person_hist: Person object as of 2011-02-15 17:23:20.483243>
# The datetime doesn't have to be exact.  We will return the historical
# instance that's most recent, moving backward in time.
>>> m.history.as_of(date=datetime(2011, 2, 15, 17, 23, 21))
<Person_hist: Person object as of 2011-02-15 17:23:20.483243>

We can also do lookups on the *model class itself*.  This is especially
important if we don't have a model instance around -- say, if the model was
most recently deleted.

>>> m2 = Person(name="Mike")
>>> m2.save()
>>> Person.history.all()
[<Person_hist: Person object as of 2011-02-15 21:53:15.613445>, <Person_hist: Person object as of 2011-02-15 20:33:03.409725>, <Person_hist: Person object as of 2011-02-15 18:07:40.645975>, <Person_hist: Person object as of 2011-02-15 17:23:40.416443>, <Person_hist: Person object as of 2011-02-15 17:23:20.483243>]
# We can also do a filter on all historical instances of the Person
# model.
>>> Person.history.filter(name="Mike")
[<Person_hist: Person object as of 2011-02-15 21:53:15.613445>]
# And we can filter based on historical info attributes, too.
>>> Person.history.filter(history_info__date__gte=datetime(2011, 2, 15, 20))
[<Person_hist: Person object as of 2011-02-15 21:53:15.613445>, <Person_hist: Person object as of 2011-02-15 20:33:03.409725>]

Smart related object lookup
---------------------------

When a versioned model is related to another versioned model via a foreign
key [#]_ lookups of the related object on the historical instance will refer
to that related object *at the time the parent instance was saved*.  Here's an
example:

Suppose we have:

    class Profile(models.Model):
        details = models.TextField()
        person = models.ForeignKey(Person)
    
        history = TrackChanges()

>>> philip = Person.objects.get(name='Philip')
>>> profile = Profile(details="Long walks on the beach", person=philip)
>>> profile.save()
# Now we change the description on the related model.
>>> philip.description = "Runs fast, writes code"
>>> philip.save()
# We get the most recent historical instance of the Profile object.
>>> profile_hist = profile.history.most_recent()
# This gives us a historical instance of the Person model at the
# correct point in time:
>>> profile_hist.person
<Person_hist: Person object as of 2011-02-15 20:33:03.409725>
>>> profile_hist.person.description
u'Some dude'
# The older description is displayed!  Yay!

This works similarly for ``OneToOneField`` and ``ManyToManyField``.

Reverse lookups do the right thing, too!  With a reverse lookup, 

***********************
here
***********************

Some more examples
------------------

Get all historical versions where the model was added, not just updated:

>>> from versionutils.versioning.constants import *
>>> Person.history.filter(history_info__type=TYPE_ADDED)
[<Person_hist: Person object as of 2011-02-15 21:53:15.613445>, <Person_hist: Person object as of 2011-02-15 17:23:20.483243>]


Notes
=====

Smart lookups
-------------

We try do our best to be smart about unique fields! For instance, if you delete and then recreate a model (so it has a new integer primary key), we'll still pull up the correct history of the model based on its unique fields, if possible.

However, if you rename a unique field on a model you'll notice that it will clear out the history of the model unless there was a model with that same field in the past (in which case you'll see that model's history). If you'd like to rename all the historical versions' unique fields you'll want to do that by hand, kinda like this:

>>> p.name = "New name!"
# 'name' is a unique field
>>> for p_h in p.history.all():
>>>     p_h.name = "New name!"
>>>     p_h.save(track_changes=False)
>>> p.save()

Bulk QuerySet update() / Admin bulk actions
-------------------------------------------
django-trackchanges works fine with QuerySet.delete() and the admin's bulk deleting.  However, at the moment there's no way to have it work with QuerySet.update().  We recommend not using QuerySet.update() on models you want to perserve versioning information on.

Working around this is braindead-easy!  See http://code.trac.localwiki.org/ticket/33 for a workaround.  Issuing a QuerySet.update() won't break anything -- it just won't save a new version of the model in the history.

For more information, see Django ticket #12184 (http://code.djangoproject.com/ticket/12184), #10754 (http://code.djangoproject.com/ticket/10754) and our ticket #33 (http://code.trac.localwiki.org/ticket/33).  Weigh in!

Migrations / syncdb
-------------------
Each versioned model has a corresponding ``*_hist`` table.  So when you change the schema of models you have versioned you'll need to execute similar SQL / migrations on the history tables as your model tables.

For instance:

Model ``Member`` is stored in my ``members_member`` table.  I'd normally run
(postgres, adjust accordingly)
``ALTER TABLE members_member ADD COLUMN newcolumn varchar(10);``
Because the members object is set to be versioned, I'll also want to run
``ALTER TABLE members_member_history ADD COLUMN newcolumn varchar(10);``

I haven't used any of the automated Django schema migration utilities, but I assume they will either 1) work automatically, as they will detect the schema change or 2) need a bit of direction to do whatever they do to the base model to the versioned model as well.

Because there's no magic here -- there's really a separate _hist table for each of your model's tables, migrations should be straightforward.

.. [#] All related fields are supported.  ``ForeignKey``, ``OneToOneField``, and ``ManyToManyField``.  Currently (2011-2-15), ManyToManyFields with custom intermediate models aren't supported but `will be soon <http://code.trac.localwiki.org/ticket/52/>`_. 
