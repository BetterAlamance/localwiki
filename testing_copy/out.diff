diff --git a/sapling/ckeditor/models.py b/sapling/ckeditor/models.py
index df1b727..d8d19ee 100644
--- a/sapling/ckeditor/models.py
+++ b/sapling/ckeditor/models.py
@@ -33,11 +33,13 @@ def custom_sanitizer(allowed):
 
     return CustomSanitizer
 
+
 def sanitize_html(unsafe):
     p = html5lib.HTMLParser(tokenizer=sanitizer.HTMLSanitizer)
     tree = p.parse(unsafe)
     return tree.toxml()
 
+
 def sanitize_html_fragment(unsafe, allowed_elements=None):
     if not allowed_elements:
         allowed_elements = sanitizer.HTMLSanitizer.allowed_elements
@@ -45,6 +47,7 @@ def sanitize_html_fragment(unsafe, allowed_elements=None):
     tree = p.parseFragment(unsafe)
     return tree.toxml()
 
+
 class XMLField(models.TextField):
     description = _("XML text")
 
@@ -53,12 +56,12 @@ class XMLField(models.TextField):
         self.default_validators = [XMLValidator(schema_path)]
         models.Field.__init__(self, verbose_name, name, **kws)
 
-    
+
 class XHTMLField(XMLField):
     """Note: this needs a real schema document before it will work!"""
     description = _("XHTML text")
     schema_path = os.path.join(os.path.dirname(__file__), 'schema', 'html.ng')
-    
+
     def __init__(self, verbose_name=None, name=None, **kwargs):
         super(XHTMLField, self).__init__(verbose_name, name,
                                         self.schema_path, **kwargs)
@@ -66,15 +69,15 @@ class XHTMLField(XMLField):
 
 class HTML5Field(models.TextField):
     description = _("HTML5 text")
-    
+
     def __init__(self, verbose_name=None, name=None, **kwargs):
         models.Field.__init__(self, verbose_name, name, **kwargs)
-        
+
     def clean(self, value, model_instance):
         super(HTML5Field, self).clean(value, model_instance)
         return sanitize_html(value)
 
-    
+
 class HTML5FragmentField(models.TextField):
     """
     Use this field in your models for storing user-editable HTML fragments.
@@ -84,23 +87,23 @@ class HTML5FragmentField(models.TextField):
     whitelisted attributes will be stripped.
     You can customize the whitelisted elements by setting the allowed_elements
     argument like this:
-    
+
     class Page(models.Model):
         contents = HTML5FragmentField(
             allowed_elements=['p', 'a', 'strong', 'em']
         )
     """
     description = _("HTML5 fragment text")
-    
+
     def __init__(self, verbose_name=None, name=None, allowed_elements=None,
                  **kwargs):
         models.Field.__init__(self, verbose_name, name, **kwargs)
         self.allowed_elements = allowed_elements
-        
+
     def clean(self, value, model_instance):
         super(HTML5FragmentField, self).clean(value, model_instance)
         return sanitize_html_fragment(value, self.allowed_elements)
-    
+
     def formfield(self, **kwargs):
         defaults = {
             'widget': widgets.CKEditor(
diff --git a/sapling/ckeditor/tests/tests.py b/sapling/ckeditor/tests/tests.py
index a6f45dd..d7b6f49 100644
--- a/sapling/ckeditor/tests/tests.py
+++ b/sapling/ckeditor/tests/tests.py
@@ -10,40 +10,50 @@ from ckeditor.models import HTML5Field
 from ckeditor.models import HTML5FragmentField
 import xssattacks
 
+
 class XHTMLModel(models.Model):
     html = XHTMLField()
-    
+
+
 class HTML5Model(models.Model):
     html = HTML5Field()
-    
+
+
 class HTML5FragmentModel(models.Model):
     html = HTML5FragmentField()
 
+
 class XHTMLFieldTest(TestCase):
     def test_html_schema_set(self):
         html = XHTMLField()
         self.assertTrue(isinstance(html, XMLField))
         self.assertEquals(html.schema_path, XHTMLField.schema_path)
-    
+
     def test_html_schema_exists(self):
         self.assertTrue(os.path.exists(XHTMLField.schema_path))
-        
+
     def test_valid_html(self):
         m = XHTMLModel()
-        m.html = '<html><head><title>Lorem</title></head><body>Ipsum</body></html>'
+        m.html = ('<html><head><title>Lorem</title></head>'
+                  '<body>Ipsum</body></html>')
         m.clean_fields()
-        
+
     def test_invalid_html(self):
         m = XHTMLModel()
         m.html = 'invalid html'
         self.assertRaises(exceptions.ValidationError, m.clean_fields)
 
+
 class HTML5FieldTest(TestCase):
     def test_sanitize(self):
         m = HTML5Model()
         m.html = '<html><head/><body><script/></body></html>'
         m.clean_fields()
-        self.assertEquals(m.html, '<html><head/><body>&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;script/&gt;&lt;/body&gt;&lt;/html&gt;</body></html>')
+        self.assertEquals(m.html,
+            ('<html><head/><body>&lt;html&gt;&lt;head/&gt;&lt;body&gt;'
+             '&lt;script/&gt;&lt;/body&gt;&lt;/html&gt;</body></html>')
+        )
+
 
 class HTML5FragmentField(TestCase):
     def test_sanitize(self):
@@ -51,7 +61,8 @@ class HTML5FragmentField(TestCase):
         m.html = '<script/>'
         m.clean_fields()
         self.assertEquals(m.html, '&lt;script/&gt;')
-  
+
+
 class XSSTest(TestCase):
     def test_xss_attacks_xhtml(self):
         for doc in xssattacks.xss_attacks():
diff --git a/sapling/ckeditor/views.py b/sapling/ckeditor/views.py
index 63370d4..1a9142f 100644
--- a/sapling/ckeditor/views.py
+++ b/sapling/ckeditor/views.py
@@ -6,31 +6,33 @@ from django.conf import settings
 from django.core.files.storage import FileSystemStorage
 from django.views.generic.simple import direct_to_template
 
+
 def ck_upload(request, upload_folder):
     error_message = 'Unable to upload'
-    
+
     upload_location = os.path.join(settings.MEDIA_ROOT, upload_folder)
     upload_url = urlparse.urljoin(settings.MEDIA_URL, upload_folder)
-    
+
     if request.method == "POST":
-        filesystem = FileSystemStorage(location=upload_location, base_url=upload_url)
+        filesystem = FileSystemStorage(location=upload_location,
+                                       base_url=upload_url)
         try:
             uploaded_file = request.FILES['upload']
             saved_file = filesystem.save(uploaded_file.name, uploaded_file)
             saved_url = filesystem.url(saved_file)
-        except Error:
+        except Exception:
             return HttpResponse(error_message)
-          
+
         try:
             callback = request.GET['CKEditorFuncNum']
         except KeyError:
             callback = ''
     else:
         return HttpResponse(error_message)
-         
+
     context = {
         'callback': callback,
         'saved_url': saved_url,
         }
-    
+
     return direct_to_template(request, 'ckeditor/upload_result.html', context)
diff --git a/sapling/ckeditor/widgets.py b/sapling/ckeditor/widgets.py
index f88c416..c85e051 100644
--- a/sapling/ckeditor/widgets.py
+++ b/sapling/ckeditor/widgets.py
@@ -43,26 +43,26 @@ class CKEditor(forms.Textarea):
                    ('Table', 'table'),
                    ('HorizontalRule', 'hr'),
                    )
-    
+
     def __init__(self, *args, **kwargs):
         super(CKEditor, self).__init__(*args, **kwargs)
         if 'attrs' in kwargs:
             attrs = kwargs['attrs']
             if 'allowed_tags' in attrs:
                 self.config = self.default_config(attrs['allowed_tags'])
-                
+
     def default_config(self, buttons=None):
         toolbar = []
         if buttons:
             for name, tag in self._auto_button_map:
                 if tag in buttons:
                     toolbar.append(name)
-                    
+
         return json.dumps(
             {'toolbar': [toolbar], 'filebrowserInsertimageUploadUrl': 'upload',
              'extraPlugins': 'insertimage,simpleimage'}
         )
-                
+
     def button_for_tag(self, tag):
         if tag in self._auto_button_map:
             return self._auto_button_map[tag]
@@ -73,13 +73,13 @@ class CKEditor(forms.Textarea):
         rendered = super(CKEditor, self).render(name, value, attrs)
         context = {
             'name': name,
-            'config': self.config 
+            'config': self.config
         }
-        return rendered +  mark_safe(render_to_string(
+        return rendered + mark_safe(render_to_string(
             'ckeditor/ckeditor_script.html', context
         ))
 
     class Media:
         js = (
-                urljoin(settings.STATIC_URL, ckeditor_path),  
+                urljoin(settings.STATIC_URL, ckeditor_path),
         )
diff --git a/sapling/pages/forms.py b/sapling/pages/forms.py
index 658f68c..3b54181 100644
--- a/sapling/pages/forms.py
+++ b/sapling/pages/forms.py
@@ -4,20 +4,26 @@ from django.template.defaultfilters import slugify
 from versionutils.merging.forms import MergeModelForm
 from pages.models import Page
 from versionutils.diff.daisydiff.daisydiff import daisydiff_merge
-        
+
+
 class PageForm(MergeModelForm):
-    conflict_warning = 'Warning: someone else saved this page before you.  Please resolve edit conflicts and save again.'
-    
+    conflict_warning = (
+        "Warning: someone else saved this page before you.  "
+        "Please resolve edit conflicts and save again."
+    )
+
     class Meta:
         model = Page
         fields = ('name', 'content')
-        
+
     def merge(self, yours, theirs, ancestor):
         # ancestor may be None
         ancestor_content = ''
         if ancestor:
             ancestor_content = ancestor['content']
-        (merged_content, conflict) = daisydiff_merge(yours['content'], theirs['content'], ancestor_content)
+        (merged_content, conflict) = daisydiff_merge(
+            yours['content'], theirs['content'], ancestor_content
+        )
         if conflict:
             self.data = self.data.copy()
             self.data['content'] = merged_content
@@ -25,13 +31,15 @@ class PageForm(MergeModelForm):
         else:
             yours['content'] = merged_content
         return yours
-    
+
     def clean_name(self):
         name = self.cleaned_data['name']
         try:
             page = Page.objects.get(slug__exact=slugify(name))
             if self.instance != page:
-                raise forms.ValidationError('A page with this name already exists')
+                raise forms.ValidationError(
+                    'A page with this name already exists'
+                )
         except Page.DoesNotExist:
             pass
         return name
diff --git a/sapling/pages/models.py b/sapling/pages/models.py
index 9a186f1..248f480 100644
--- a/sapling/pages/models.py
+++ b/sapling/pages/models.py
@@ -5,20 +5,23 @@ from ckeditor.models import HTML5FragmentField
 from versionutils import diff
 from versionutils.versioning import TrackChanges
 
+
 class Page(models.Model):
     name = models.CharField(max_length=255)
     slug = models.SlugField(max_length=255, editable=False, unique=True)
-    content = HTML5FragmentField(allowed_elements=['p', 'a', 'em', 'strong', 'img'])
+    content = HTML5FragmentField(
+        allowed_elements=['p', 'a', 'em', 'strong', 'img']
+    )
     history = TrackChanges()
-    
+
     def save(self, *args, **kwargs):
         self.slug = slugify(self.name)
         super(Page, self).save(*args, **kwargs)
 
 
 class PageDiff(diff.BaseModelDiff):
-    fields = ('name', 
+    fields = ('name',
               ('content', diff.diffutils.HtmlFieldDiff),
              )
-   
+
 diff.register(Page, PageDiff)
diff --git a/sapling/pages/views.py b/sapling/pages/views.py
index 8d323f3..0caab69 100644
--- a/sapling/pages/views.py
+++ b/sapling/pages/views.py
@@ -9,25 +9,29 @@ from utils.views import Custom404Mixin, CreateObjectMixin
 from django.shortcuts import get_object_or_404, redirect
 from ckeditor.views import ck_upload
 
+
 class PageDetailView(Custom404Mixin, DetailView):
     model = Page
     context_object_name = 'page'
-    
-    def handler404(self, request, slug): 
-        return HttpResponseNotFound(direct_to_template(request, 'pages/page_new.html', {'name': slug}))
-    
+
+    def handler404(self, request, slug):
+        return HttpResponseNotFound(
+            direct_to_template(request, 'pages/page_new.html', {'name': slug})
+        )
+
     def get_context_data(self, **kwargs):
         context = super(PageDetailView, self).get_context_data(**kwargs)
         context['date'] = self.object.history.most_recent().history_info.date
         return context
 
+
 class PageVersionDetailView(PageDetailView):
     template_name = 'pages/page_detail.html'
-    
+
     def get_object(self):
         page = get_object_or_404(Page, slug__iexact=self.kwargs['slug'])
         return page.history.as_of(version=int(self.kwargs['version']))
-    
+
     def get_context_data(self, **kwargs):
         # we don't want PageDetailView's context, skip to DetailView's
         context = super(DetailView, self).get_context_data(**kwargs)
@@ -35,20 +39,22 @@ class PageVersionDetailView(PageDetailView):
         context['show_revision'] = True
         return context
 
+
 class PageUpdateView(CreateObjectMixin, UpdateView):
     model = Page
     form_class = PageForm
-    
+
     def get_success_url(self):
         return reverse('show-page', args=[self.object.slug])
-    
+
     def create_object(self):
-        return Page(name=self.kwargs['slug']) 
+        return Page(name=self.kwargs['slug'])
+
 
 class PageHistoryView(ListView):
     context_object_name = "version_list"
     template_name = "pages/page_history.html"
-    
+
     def get_queryset(self):
         self.page = get_object_or_404(Page, slug__iexact=self.kwargs['slug'])
         return self.page.history.all()
@@ -57,7 +63,8 @@ class PageHistoryView(ListView):
         context = super(PageHistoryView, self).get_context_data(**kwargs)
         context['page'] = self.page
         return context
-    
+
+
 def compare(request, slug, version1=None, version2=None):
     versions = request.GET.getlist('version')
     if not versions:
@@ -74,6 +81,7 @@ def compare(request, slug, version1=None, version2=None):
     new_version = page.history.as_of(version=new)
     context = {'old': old_version, 'new': new_version, 'page': page}
     return direct_to_template(request, 'pages/page_diff.html', context)
-    
+
+
 def upload(request, slug):
     return ck_upload(request, 'ck_upload/')
diff --git a/sapling/settings.py b/sapling/settings.py
index 4b983ec..0376422 100644
--- a/sapling/settings.py
+++ b/sapling/settings.py
@@ -88,7 +88,10 @@ INSTALLED_APPS = (
     'django.contrib.contenttypes',
     'django.contrib.sessions',
     'django.contrib.sites',
-    'django.contrib.staticfiles',
+# DONT COMMIT THIS..arggh
+    #'django.contrib.staticfiles',
+
+    'philiptest',
 
     # Our apps
     'versionutils.versioning',
diff --git a/sapling/utils/views.py b/sapling/utils/views.py
index 34a7b54..fa15231 100644
--- a/sapling/utils/views.py
+++ b/sapling/utils/views.py
@@ -1,6 +1,7 @@
 from django.utils.decorators import classonlymethod
 from django.http import Http404
 
+
 class Custom404Mixin(object):
     @classonlymethod
     def as_view(cls, **initargs):
@@ -20,7 +21,7 @@ class Custom404Mixin(object):
 class CreateObjectMixin(object):
     def create_object(self):
         self.form_class._meta.model()
-        
+
     def get_object(self, queryset=None):
         try:
             return super(CreateObjectMixin, self).get_object(queryset)
diff --git a/sapling/versionutils/diff/daisydiff/daisydiff.py b/sapling/versionutils/diff/daisydiff/daisydiff.py
index 365a2e2..6d1aff1 100644
--- a/sapling/versionutils/diff/daisydiff/daisydiff.py
+++ b/sapling/versionutils/diff/daisydiff/daisydiff.py
@@ -6,16 +6,20 @@ import lxml
 from django.conf import settings
 from django.utils.http import urlencode
 
-DAISYDIFF_URL = getattr(settings, 'DAISYDIFF_URL', 'http://localhost:8080/diff')
-DAISYDIFF_MERGE_URL = getattr(settings, 'DAISYDIFF_MERGE_URL', 'http://localhost:8080/merge')
+DAISYDIFF_URL = getattr(settings, 'DAISYDIFF_URL',
+    'http://localhost:8080/diff')
+DAISYDIFF_MERGE_URL = getattr(settings, 'DAISYDIFF_MERGE_URL',
+    'http://localhost:8080/merge')
+
 
 class ServiceUnavailableError(Exception):
     def __init__(self, value):
         self.value = value
-    
+
     def __str__(self):
         return repr(self.value)
 
+
 def daisydiff(field1, field2, service_url=DAISYDIFF_URL):
     """
     Gets the HTML diff from the DaisyDiff server and returns it
@@ -25,7 +29,7 @@ def daisydiff(field1, field2, service_url=DAISYDIFF_URL):
     headers = {"Content-type": "application/x-www-form-urlencoded",
                "Accept": "text/html"}
     split_url = urlparse.urlsplit(service_url)
-    
+
     conn = httplib.HTTPConnection(split_url.netloc)
     conn.request("POST", split_url.path, params, headers)
     response = conn.getresponse()
@@ -36,17 +40,19 @@ def daisydiff(field1, field2, service_url=DAISYDIFF_URL):
     conn.close()
     return extract_table_row(data)
 
+
 def daisydiff_merge(field1, field2, ancestor, service_url=DAISYDIFF_MERGE_URL):
     """
-    Uses the DaisyDiff server to merge the two versions of the field, given a common
-    ancestor and returns the tuple (merged_version, has_conflict) where has_conflict
-    is True if the merge could not be done cleanly.
+    Uses the DaisyDiff server to merge the two versions of the field, given a
+    common ancestor and returns the tuple (merged_version, has_conflict) where
+    has_conflict is True if the merge could not be done cleanly.
     """
-    params = urlencode({'field1': field1, 'field2': field2, 'ancestor': ancestor})
+    params = urlencode({'field1': field1, 'field2': field2,
+                        'ancestor': ancestor})
     headers = {"Content-type": "application/x-www-form-urlencoded",
                "Accept": "text/html"}
     split_url = urlparse.urlsplit(service_url)
-    
+
     conn = httplib.HTTPConnection(split_url.netloc)
     conn.request("POST", split_url.path, params, headers)
     response = conn.getresponse()
@@ -57,6 +63,7 @@ def daisydiff_merge(field1, field2, ancestor, service_url=DAISYDIFF_MERGE_URL):
     conn.close()
     return extract_merge(data)
 
+
 def extract_merge(xml):
     doc = lxml.etree.fromstring(xml)
     body_list = [lxml.etree.tostring(child) for child in doc.find('body')]
@@ -64,10 +71,12 @@ def extract_merge(xml):
     has_conflict = 'true' in doc.find('conflict').text
     return (body, has_conflict)
 
+
 def extract_table_row(html):
     doc = html5lib.parse(html)
     return find_element_by_tag('tr', doc).toxml()
 
+
 def find_element_by_tag(tag, node):
     """
     Depth-first search for first element with the given tag
diff --git a/sapling/versionutils/diff/daisydiff/tests.py b/sapling/versionutils/diff/daisydiff/tests.py
index 8cb3f83..fc2e333 100644
--- a/sapling/versionutils/diff/daisydiff/tests.py
+++ b/sapling/versionutils/diff/daisydiff/tests.py
@@ -6,6 +6,7 @@ from versionutils.diff.daisydiff.daisydiff import daisydiff_merge
 
 TEST_SERVICE = hasattr(settings, 'DAISYDIFF_URL')
 
+
 def skipUnlessHasService(test):
     def do_nothing(*args, **kwargs):
         print "Skipping %r (DAISYDIFF_URL not in settings.py)" % test.__name__
@@ -13,15 +14,16 @@ def skipUnlessHasService(test):
         return do_nothing
     return test
 
+
 class DaisyDiffTest(TestCase):
     def test_bad_url_throws_exception(self):
         self.assertRaises(socket.error, daisydiff, 'abc', 'abc', 'badurl')
-    
+
     def url_set(self):
         return hasattr(settings, 'DAISYDIFF_URL')
-    
+
     @skipUnlessHasService
-    def test_server_is_running(self):        
+    def test_server_is_running(self):
         import httplib
         import urlparse
         split_url = urlparse.urlsplit(settings.DAISYDIFF_URL)
@@ -29,28 +31,38 @@ class DaisyDiffTest(TestCase):
         conn.request("GET", split_url.path)
         r1 = conn.getresponse()
         self.assertEquals(r1.status, 200)
-        
+
     @skipUnlessHasService
     def test_daisydiff_service(self):
         tr = daisydiff('abc', 'def')
         self.failUnless('abc</del>' in tr)
         self.failUnless('def</ins>' in tr)
-        
+
+
 class DaisyDiffMergeTest(TestCase):
     def test_bad_url_throws_exception(self):
-        self.assertRaises(socket.error, daisydiff_merge, 'abc', 'abc', 'abc', 'badurl')
-    
+        self.assertRaises(socket.error, daisydiff_merge,
+            'abc', 'abc', 'abc', 'badurl')
+
     @skipUnlessHasService
     def test_merge_clean(self):
-        (body, conflict) = daisydiff_merge('<p>New stuff before</p><p>Original</p>', '<p>Original</p><p>New stuff after</p>', '<p>Original</p>')
+        (body, conflict) = daisydiff_merge(
+            '<p>New stuff before</p><p>Original</p>',
+            '<p>Original</p><p>New stuff after</p>',
+            '<p>Original</p>'
+        )
         self.failUnless(conflict is False)
         self.failUnless('New stuff before' in body)
         self.failUnless('Original' in body)
         self.failUnless('New stuff after' in body)
-        
+
     @skipUnlessHasService
     def test_merge_conflict(self):
-        (body, conflict) = daisydiff_merge('<p>First version</p>', '<p>Second version</p>', '<p>Original</p>')
+        (body, conflict) = daisydiff_merge(
+            '<p>First version</p>',
+            '<p>Second version</p>',
+            '<p>Original</p>'
+        )
         self.failUnless(conflict is True)
         self.failUnless('Edit conflict' in body)
         self.failUnless('First version' in body)
diff --git a/sapling/versionutils/diff/diffutils.py b/sapling/versionutils/diff/diffutils.py
index 89a456c..e0a4ebe 100644
--- a/sapling/versionutils/diff/diffutils.py
+++ b/sapling/versionutils/diff/diffutils.py
@@ -8,6 +8,7 @@ from django.conf import settings
 import diff_match_patch
 import daisydiff
 
+
 class DiffUtilNotFound(Exception):
     """
     No appropriate diff util registered for this object.
@@ -23,16 +24,16 @@ class BaseFieldDiff():
     implement (at minimum) get_diff() and as_html() and register your
     class either for a certain field type or for a specific field of a
     specific model.  See BaseModelDiff for details on the latter.
-    
+
     Here's how you might create your own diff util and register it for
     a field type::
-    
+
         class MyIntegerDiff(BaseFieldDiff):
             def get_diff(self):
                 if self.field1 == self.field2:
                     return None
                 return {'difference': (self.field2 - self.field1)}
-            
+
             def as_html(self):
                 d = self.get_diff()
                 if d is None:
@@ -41,7 +42,7 @@ class BaseFieldDiff():
                     return 'New value is larger'
                 return 'New value is smaller'
                 Unchanged
-                
+
         diff.register(models.IntegerField, MyIntegerDiff)
 
     Attributes:
@@ -50,7 +51,7 @@ class BaseFieldDiff():
         template: An optional filename of the template to use when rendering.
     """
     template = None
-    
+
     def __init__(self, field1, field2):
         """
         Args:
@@ -59,7 +60,7 @@ class BaseFieldDiff():
         """
         self.field1 = field1
         self.field2 = field2
-        
+
     def get_diff(self):
         """
         Compares the two field values (field1 and field2).
@@ -71,15 +72,15 @@ class BaseFieldDiff():
         """
         if self.field1 == self.field2:
             return None
-        return { 'deleted': self.field1, 'inserted': self.field2 }
-    
+        return {'deleted': self.field1, 'inserted': self.field2}
+
     def as_dict(self):
         """
         Returns:
             The diff as a dictionary or array of dictionaries.
         """
         return self.get_diff()
-    
+
     def as_html(self):
         """
         Returns:
@@ -89,36 +90,36 @@ class BaseFieldDiff():
         diff = self.as_dict()
         if self.template:
             return render_to_string(self.template, diff)
-        
+
         if diff is None:
             return '<tr><td colspan="2">(No differences found)</td></tr>'
         return '<tr><td>%s</td><td>%s</td></tr>' % (self.field1, self.field2)
-        
+
     def __str__(self):
         return self.as_html()
-    
+
     def __unicode__(self):
         return mark_safe(unicode(self.__str__()))
 
-    
+
 class BaseModelDiff(object):
     """
-    Diff util used for comparing two model instances.  By default, it will compare
-    the instances on all of their fields, except AutoFields.
+    Diff util used for comparing two model instances.  By default, it will
+    compare the instances on all of their fields, except AutoFields.
     To customize which fields to compare, subclass BaseModelDiff, setting the
     'fields' or 'excludes' attributes like this::
-    
+
         class MyModelDiff(diff.BaseModelDiff):
-            fields =   ('name', 
+            fields =   ('name',
                         'contents')
-                    
+
     and then register it with your model like this::
-    
+
         diff.register(MyModel, MyModelDiff)
-    
+
     You can also customize how each field is compared by using a tuple
     ('field_name', FieldDiff) instead of just the field names, like this::
-    
+
         class MyModelDiff(diff.BaseModelDiff):
             fields =   ( ('name', diff.TextFieldDiff),
                          ('contents', diff.HtmlFieldDiff),
@@ -129,11 +130,11 @@ class BaseModelDiff(object):
             ('field_name', FieldDiff).  The listed fields will be
             diffed.
         excludes: An optional tuple of field names to ignore.
-            
+
     """
     fields = None
     excludes = ()
-    
+
     def __init__(self, model1, model2):
         """
         Args:
@@ -143,7 +144,7 @@ class BaseModelDiff(object):
         """
         self.model1 = model1
         self.model2 = model2
-    
+
     def as_dict(self):
         """
         Returns:
@@ -157,13 +158,13 @@ class BaseModelDiff(object):
         if not diffs:
             return None
         return diffs
-    
+
     def as_html(self):
         """
         Renders the diffs between the model instances as an HTML table. Only
         those fields that are different will be rendered as rows in the
         table. Fields that are not different will be skipped.
-       
+
         Returns:
             An html string string representing the differences between
             model1 and model2.
@@ -178,12 +179,12 @@ class BaseModelDiff(object):
             if not isinstance(name, basestring):
                 name = name[0]
             if diffs[name].get_diff():
-                diff_str.append('<tr><td colspan="2">%s</td></tr>' % (name,))
-                diff_str.append('%s' % (diffs[name],))
+                diff_str.append('<tr><td colspan="2">%s</td></tr>' % (name, ))
+                diff_str.append('%s' % (diffs[name], ))
         if diff_str:
             return '\n'.join(diff_str)
         return '<tr><td colspan="2">No differences found</td></tr>'
-            
+
     def get_diff(self):
         """
         Returns:
@@ -191,11 +192,11 @@ class BaseModelDiff(object):
         """
         diff = {}
         diff_utils = {}
-        
+
         if self.fields:
             diff_fields = self.fields
         else:
-            diff_fields = [ f.name for f in self.model1._meta.fields ]
+            diff_fields = [f.name for f in self.model1._meta.fields]
 
         for name in diff_fields:
             if isinstance(name, basestring):
@@ -205,31 +206,31 @@ class BaseModelDiff(object):
                 field = self.model1._meta.get_field(name[0])
                 diff_class = name[1]
             diff_utils[field] = diff_class
-                
+
         for field, diff_class in diff_utils.items():
             if not (isinstance(field, (models.AutoField,
                                        ))
                     ):
                 if field.name in self.excludes:
                     continue
-                
+
                 diff[field.name] = diff_class(
                     getattr(self.model1, field.name),
                     getattr(self.model2, field.name)
                 )
 
         return diff
-        
+
     def __str__(self):
         return self.as_html()
-    
+
     def __unicode__(self):
         """
         For use in templates, returns a safe string.
         """
         return mark_safe(unicode(self.__str__()))
 
-    
+
 class TextFieldDiff(BaseFieldDiff):
     """
     Compares the fields as text and renders the diff in an easy to read format.
@@ -241,11 +242,11 @@ class TextFieldDiff(BaseFieldDiff):
         if d is None:
             return '<tr><td colspan="2">(No differences found)</td></tr>'
         return render_to_string(self.template, {'diff': d})
-    
+
     def get_diff(self):
         return get_diff_operations_clean(self.field1, self.field2)
 
-    
+
 class HtmlFieldDiff(BaseFieldDiff):
     """
     Compares the fields as HTML and renders them side-by-side, with the
@@ -254,7 +255,7 @@ class HtmlFieldDiff(BaseFieldDiff):
     diff.register(MyHtmlField, diff.HtmlFieldDiff)
     """
     DAISYDIFF_URL = getattr(settings, 'DAISYDIFF_URL', 'http://localhost:8080')
-    
+
     def as_html(self):
         d = self.get_diff()
         if d is None:
@@ -264,13 +265,13 @@ class HtmlFieldDiff(BaseFieldDiff):
                                        self.DAISYDIFF_URL)
         except:
             return TextFieldDiff(d['deleted'], d['inserted']).as_html()
-    
+
     def get_diff(self):
         if self.field1 == self.field2:
             return None
         return {'deleted': self.field1, 'inserted': self.field2}
-        
-    
+
+
 class FileFieldDiff(BaseFieldDiff):
     """
     Compares the fields as file paths and renders links to the files.
@@ -279,23 +280,27 @@ class FileFieldDiff(BaseFieldDiff):
 
     def get_diff(self):
         """
-        Returns a dictionary of all the file attributes or None if it's the same file
+        Returns a dictionary of all the file attributes or None if it's the
+        same file.
         """
         if self.field1 == self.field2:
             return None
-        
+
         diff = {
-                'name': { 'deleted': self.field1.name, 'inserted': self.field2.name },
-                'url': { 'deleted': self.field1.url, 'inserted': self.field2.url },
+                'name': {'deleted': self.field1.name,
+                         'inserted': self.field2.name},
+                'url': {'deleted': self.field1.url,
+                        'inserted': self.field2.url},
                }
         return diff
-    
+
     def as_html(self):
         d = self.get_diff()
         if d is None:
             return '<tr><td colspan="2">(No differences found)</td></tr>'
         return render_to_string(self.template, {'diff': d})
 
+
 class ImageFieldDiff(FileFieldDiff):
     """
     Compares the fields as image file paths and renders the images.
@@ -307,10 +312,11 @@ class ImageFieldDiff(FileFieldDiff):
         if d is None:
             return '<tr><td colspan="2">(No differences found)</td></tr>'
         return render_to_string(self.template, {'diff': d})
-        
+
+
 def get_diff_operations(a, b):
     """
-    Returns the minimal diff operations between two strings, using difflib. 
+    Returns the minimal diff operations between two strings, using difflib.
     """
     if a == b:
         return None
@@ -323,12 +329,13 @@ def get_diff_operations(a, b):
         deleted = ''.join(a[start_a:end_a])
         inserted = ''.join(b[start_b:end_b])
         if operation == 'equal':
-            operations.append({ 'equal' : inserted })
+            operations.append({'equal': inserted})
         else:
-            operations.append({ 'deleted': deleted,
-                                'inserted': inserted })
+            operations.append({'deleted': deleted,
+                                'inserted': inserted})
     return operations
 
+
 def get_diff_operations_clean(a, b):
     """
     Returns a cleaned-up, more human-friendly set of diff operations between
@@ -339,14 +346,15 @@ def get_diff_operations_clean(a, b):
     dmp = diff_match_patch.diff_match_patch()
     dmp.Diff_Timeout = 0.01
     dmp.Diff_EditCost = 4
-    
+
     diff = dmp.diff_main(a, b, False)
     dmp.diff_cleanupSemantic(diff)
-    op_map = { diff_match_patch.diff_match_patch.DIFF_DELETE: 'deleted',
-               diff_match_patch.diff_match_patch.DIFF_EQUAL: 'equal',
-               diff_match_patch.diff_match_patch.DIFF_INSERT: 'inserted'
-              }
-    return [ { op_map[op]: data } for op, data in diff ]
+    op_map = {diff_match_patch.diff_match_patch.DIFF_DELETE: 'deleted',
+              diff_match_patch.diff_match_patch.DIFF_EQUAL: 'equal',
+              diff_match_patch.diff_match_patch.DIFF_INSERT: 'inserted'
+             }
+    return [{op_map[op]: data} for op, data in diff]
+
 
 class Registry(object):
     """
@@ -354,7 +362,7 @@ class Registry(object):
     """
     def __init__(self):
         self._registry = {}
-        
+
     def register(self, model_or_field, diff_util):
         """
         Registers a diff util for a particular model or field type.
@@ -369,7 +377,7 @@ class Registry(object):
                 of BaseModelDiff or BaseFieldDiff, respectively)
         """
         self._registry[model_or_field] = diff_util
-        
+
     def get_diff_util(self, model_or_field):
         if model_or_field in self._registry:
             return self._registry[model_or_field]
@@ -383,13 +391,14 @@ class Registry(object):
         if model_or_field.__base__ is not object:
             # NOTE: I think __base__ will grab the 'right' parent class.
             # This will probably work fine.  The work around
-            # (for c in __bases__) is probably too annoying to implement. 
+            # (for c in __bases__) is probably too annoying to implement.
             return self.get_diff_util(model_or_field.__base__)
-        
+
         raise DiffUtilNotFound
-        
+
 registry = Registry()
 
+
 def register(model_or_field, diff_util):
     """
     Registers a diff util for a particular model or field type.
@@ -410,10 +419,11 @@ def register(model_or_field, diff_util):
     """
     registry.register(model_or_field, diff_util)
 
+
 def diff(object1, object2):
     """
-    Compares two objects (such as model instances) and returns an object that can
-    be used to render the differences between the two objects.
+    Compares two objects (such as model instances) and returns an object that
+    can be used to render the differences between the two objects.
 
     Example::
 
@@ -446,6 +456,7 @@ def diff(object1, object2):
     diff_util = registry.get_diff_util(object1.__class__)
     return diff_util(object1, object2)
 
+
 # Built-in diff utils provided for some of the Django field types.
 register(models.CharField, TextFieldDiff)
 register(models.TextField, TextFieldDiff)
diff --git a/sapling/versionutils/diff/tests/models.py b/sapling/versionutils/diff/tests/models.py
index db29c70..3936160 100644
--- a/sapling/versionutils/diff/tests/models.py
+++ b/sapling/versionutils/diff/tests/models.py
@@ -7,24 +7,30 @@ TODO: It would be cool to write a little thing to randomly generate
 model definitions for tests.
 """
 
+
 class M1(models.Model):
     a = models.CharField(max_length=200)
     b = models.TextField()
     c = models.DateTimeField()
     d = models.IntegerField()
-    
+
+
 class M1Diff(diff.BaseModelDiff):
     fields = ('d', 'c', 'b', 'a',)
-    
+
+
 class M1FieldDiff(diff.BaseFieldDiff):
     pass
 
+
 class M2(models.Model):
     a = models.FileField(upload_to='test_diff_uploads')
 
+
 class M3(models.Model):
     a = models.ImageField(upload_to='test_diff_uploads')
-    
+
+
 class M4ForeignKey(models.Model):
     a = models.ForeignKey('M1')
 
@@ -92,4 +98,3 @@ class M4ForeignKey(models.Model):
 TEST_MODELS = [
     M1, M2
 ]
-    
diff --git a/sapling/versionutils/diff/tests/tests.py b/sapling/versionutils/diff/tests/tests.py
index a564cec..cd518bf 100644
--- a/sapling/versionutils/diff/tests/tests.py
+++ b/sapling/versionutils/diff/tests/tests.py
@@ -18,7 +18,9 @@ from models import M1, M1Diff, M1FieldDiff, M2, M3, M4ForeignKey, TEST_MODELS
 
 from versionutils import diff
 from versionutils.diff.diffutils import Registry, BaseFieldDiff, BaseModelDiff
-from versionutils.diff.diffutils import TextFieldDiff, FileFieldDiff, ImageFieldDiff
+from versionutils.diff.diffutils import TextFieldDiff
+from versionutils.diff.diffutils import FileFieldDiff
+from versionutils.diff.diffutils import ImageFieldDiff
 from versionutils.diff.diffutils import HtmlFieldDiff
 
 mgr = TestSettingsManager()
@@ -26,78 +28,87 @@ INSTALLED_APPS = list(settings.INSTALLED_APPS)
 INSTALLED_APPS.append('versionutils.diff.tests')
 mgr.set(INSTALLED_APPS=INSTALLED_APPS)
 
+
 class ModelDiffTest(TestCase):
-    
     def setUp(self):
         self.test_models = TEST_MODELS
 
     def tearDown(self):
         pass
-    
+
     def test_identical(self):
         """
-        The diff between two identical models, or a model and itself should be None
+        The diff between two identical models, or a model and itself should be
+        None.
         """
-        vals = { 'a': 'Lorem', 'b': 'Ipsum', 'c': datetime.datetime.now(), 'd': 123}
+        vals = {'a': 'Lorem', 'b': 'Ipsum',
+                'c': datetime.datetime.now(), 'd': 123}
         m1 = M1.objects.create(**vals)
         m2 = M1.objects.create(**vals)
-    
+
         d = diff.diff(m1, m1).as_dict()
         self.assertEqual(d, None)
-        
+
         d = diff.diff(m1, m2).as_dict()
         self.assertEqual(d, None)
-    
+
     def test_nearly_identical(self):
         """
-        The diff between models should consist of only the fields that are different
+        The diff between models should consist of only the fields that are
+        different.
         """
-        vals = { 'a': 'Lorem', 'b': 'Ipsum', 'c': datetime.datetime.now(), 'd': 123}
+        vals = {'a': 'Lorem', 'b': 'Ipsum',
+                'c': datetime.datetime.now(), 'd': 123}
         m1 = M1.objects.create(**vals)
         vals['a'] = 'Ipsum'
         m2 = M1.objects.create(**vals)
         d = diff.diff(m1, m2).as_dict()
         self.assertTrue(len(d) == 1)
-    
+
     def test_foreign_key_identical(self):
         """
-        The diff between two ForeignKey fields to the same object should be None
+        The diff between two ForeignKey fields to the same object should be
+        None.
         """
-        vals = { 'a': 'Lorem', 'b': 'Ipsum', 'c': datetime.datetime.now(), 'd': 123}
+        vals = {'a': 'Lorem', 'b': 'Ipsum',
+                'c': datetime.datetime.now(), 'd': 123}
         m1 = M1.objects.create(**vals)
-        
+
         m3 = M4ForeignKey.objects.create(a=m1)
         m4 = M4ForeignKey.objects.create(a=m1)
-        
+
         d = diff.diff(m3, m4).as_dict()
         self.assertTrue(d is None)
-    
+
     def test_foreign_key(self):
         """
         The diff between two ForeignKey fields should be the same as the diff
         between the two objects referenced by the fields
         """
-        vals = { 'a': 'Lorem', 'b': 'Ipsum', 'c': datetime.datetime.now(), 'd': 123}
+        vals = {'a': 'Lorem', 'b': 'Ipsum',
+                'c': datetime.datetime.now(), 'd': 123}
         m1 = M1.objects.create(**vals)
-        vals = { 'a': 'Dolor', 'b': 'Ipsum', 'c': datetime.datetime.now(), 'd': 123}
+        vals = {'a': 'Dolor', 'b': 'Ipsum',
+                'c': datetime.datetime.now(), 'd': 123}
         m2 = M1.objects.create(**vals)
-        
+
         m3 = M4ForeignKey.objects.create(a=m1)
         m4 = M4ForeignKey.objects.create(a=m2)
-        
+
         d1 = diff.diff(m3, m4).as_dict()
         self.assertTrue(d1['a'])
-        
+
         d2 = diff.diff(m1, m2).as_dict()
-        
+
         self.assertEqual(d1['a'], d2)
 
+
 class BaseFieldDiffTest(TestCase):
     test_class = BaseFieldDiff
-    
+
     def test_identical_fields_dict(self):
         """
-        The diff between two identical fields of any type should be None
+        The diff between two identical fields of any type should be None.
         """
         vals = ['Lorem', 123, True, datetime.datetime.now()]
         for v in vals:
@@ -106,22 +117,24 @@ class BaseFieldDiffTest(TestCase):
 
     def test_identical_fields_html(self):
         """
-        The html of the diff between two identical fields should be sensible message
+        The html of the diff between two identical fields should be a
+        sensible message.
         """
         a = 'Lorem'
         d = self.test_class(a, a).as_html()
         self.assertTrue("No differences" in d)
-        
+
     def test_deleted_inserted(self):
         a = 123
         b = 456
         d = self.test_class(a, b).as_dict()
         self.assertTrue(d['deleted'] == a)
         self.assertTrue(d['inserted'] == b)
-        
+
+
 class TextFieldDiffTest(BaseFieldDiffTest):
     test_class = TextFieldDiff
-    
+
     def test_deleted_inserted(self):
         a = 'abc'
         b = 'def'
@@ -129,111 +142,121 @@ class TextFieldDiffTest(BaseFieldDiffTest):
         self.assertTrue(len(d) == 2)
         self.assertTrue(d[0]['deleted'] == a)
         self.assertTrue(d[1]['inserted'] == b)
-    
+
     def test_equal(self):
         a = 'abcdef'
         b = 'abcghi'
         d = self.test_class(a, b).as_dict()
         self.assertTrue(len(d) == 3)
         self.assertTrue(d[0]['equal'] == 'abc')
-    
-    
+
+
 class FileFieldDiffTest(BaseFieldDiffTest):
     test_class = FileFieldDiff
-    
+
     def test_deleted_inserted(self):
         m1 = M2()
         m1.a.save("a.txt", ContentFile("TEST FILE"), save=False)
-        
+
         m2 = M2()
         m2.a.save("b.txt", ContentFile("TEST FILE"), save=False)
-        
+
         d = self.test_class(m1.a, m2.a).as_dict()
         self.assertTrue(d['name']['deleted'] == m1.a.name)
         self.assertTrue(d['name']['inserted'] == m2.a.name)
-        
+
         m1.a.delete()
         m2.a.delete()
 
+
 class ImageFieldDiffTest(FileFieldDiffTest):
     test_class = ImageFieldDiff
-    
+
+
 class HtmlFieldTest(TestCase):
     def test_identical_fields(self):
         htmlDiff = HtmlFieldDiff('abc', 'abc')
         self.assertEquals(htmlDiff.as_dict(), None)
-    
+
     def test_deleted_inserted(self):
         htmlDiff = HtmlFieldDiff('abc', 'def')
         self.assertTrue('def</ins>' in htmlDiff.as_html())
-    
+
     def test_daisydiff_broken_fallback(self):
         """
         In case something is wrong with the DaisyDiff service, fallback to
         text-only diff
         """
         backup = HtmlFieldDiff.DAISYDIFF_URL
-        
+
         HtmlFieldDiff.DAISYDIFF_URL = 'http://badurl'
         htmlDiff = HtmlFieldDiff('abc', 'def')
         self.assertTrue('<del>abc</del>' in htmlDiff.as_html())
-        
+
         HtmlFieldDiff.DAISYDIFF_URL = backup
-        
+
+
 class DiffRegistryTest(TestCase):
-    
     def setUp(self):
         self.registry = Registry()
-        
-        vals = { 'a': 'Lorem', 'b': 'Ipsum', 'c': datetime.datetime.now(), 'd': 123}
+
+        vals = {'a': 'Lorem', 'b': 'Ipsum',
+                'c': datetime.datetime.now(), 'd': 123}
         m1 = M1.objects.create(**vals)
-    
+
     def test_can_handle_any_field(self):
         """
-        Out of the box, the registry should offer diff utils for any field
+        Out of the box, the registry should offer diff utils for any field.
         """
         r = self.registry
-        field_types = [db.models.CharField, db.models.TextField, db.models.BooleanField]
+        field_types = [db.models.CharField, db.models.TextField,
+                       db.models.BooleanField]
         for t in field_types:
             d = r.get_diff_util(t)
             self.assertTrue(issubclass(d, BaseFieldDiff))
-    
+
     def test_can_handle_any_model(self):
         """
-        Out of the box, the registry should offer diff utils for any model
+        Out of the box, the registry should offer diff utils for any model.
         """
         r = self.registry
         for t in TEST_MODELS:
             d = r.get_diff_util(t)
-            self.assertTrue(issubclass(d, BaseModelDiff))          
-    
+            self.assertTrue(issubclass(d, BaseModelDiff))
+
     def test_fallback_diff(self):
         class AwesomeImageField(db.models.ImageField):
             pass
         """
-        If we don't have a diff util for the exact field type, we should fall back to the
-        diff util for the base class, until we find a registered util
+        If we don't have a diff util for the exact field type, we should fall
+        back to the diff util for the base class, until we find a registered
+        util.
         """
         self.registry.register(db.models.FileField, FileFieldDiff)
         d = self.registry.get_diff_util(AwesomeImageField)
         self.assertTrue(issubclass(d, FileFieldDiff))
-        
+
     def test_register_model(self):
         """
-        If we register a diff for a model, we should get that and not BaseModelDiff
+        If we register a diff for a model, we should get that and not
+        BaseModelDiff.
         """
         self.registry.register(M1, M1Diff)
         self.failUnlessEqual(self.registry.get_diff_util(M1), M1Diff)
-    
+
     def test_register_field(self):
         """
-        If we register a fielddiff for a model, we should get that and not BaseFieldDiff
+        If we register a fielddiff for a model, we should get that and not
+        BaseFieldDiff.
         """
         self.registry.register(db.models.CharField, M1FieldDiff)
-        self.failUnlessEqual(self.registry.get_diff_util(db.models.CharField), M1FieldDiff)
-        
+        self.failUnlessEqual(self.registry.get_diff_util(db.models.CharField),
+                             M1FieldDiff)
+
     def test_cannot_diff_something_random(self):
         """
-        If we try to diff something that is neither a model nor a field, raise exception.
+        If we try to diff something that is neither a model nor a field,
+        raise exception.
         """
-        self.failUnlessRaises(diff.diffutils.DiffUtilNotFound, self.registry.get_diff_util, DiffRegistryTest)
+        self.failUnlessRaises(diff.diffutils.DiffUtilNotFound,
+                              self.registry.get_diff_util, DiffRegistryTest)
diff --git a/sapling/versionutils/diff/tests/utils.py b/sapling/versionutils/diff/tests/utils.py
index 0ae7dc7..2997a41 100644
--- a/sapling/versionutils/diff/tests/utils.py
+++ b/sapling/versionutils/diff/tests/utils.py
@@ -5,6 +5,7 @@ from django.test import TestCase
 
 NO_SETTING = ('!', None)
 
+
 class TestSettingsManager(object):
     """
     A class which can modify some Django settings temporarily for a
@@ -18,7 +19,7 @@ class TestSettingsManager(object):
         self._original_settings = {}
 
     def set(self, **kwargs):
-        for k,v in kwargs.iteritems():
+        for k, v in kwargs.iteritems():
             self._original_settings.setdefault(k, getattr(settings, k,
                                                           NO_SETTING))
             setattr(settings, k, v)
@@ -29,11 +30,11 @@ class TestSettingsManager(object):
         loading.cache.loaded = False
 
     def revert(self):
-        for k,v in self._original_settings.iteritems():
+        for k, v in self._original_settings.iteritems():
             if v == NO_SETTING:
                 delattr(settings, k)
             else:
                 setattr(settings, k, v)
         if 'INSTALLED_APPS' in self._original_settings:
             self.syncdb()
-        self._original_settings = {}
\ No newline at end of file
+        self._original_settings = {}
diff --git a/sapling/versionutils/diff/views.py b/sapling/versionutils/diff/views.py
index 5d22e88..6fa93c1 100644
--- a/sapling/versionutils/diff/views.py
+++ b/sapling/versionutils/diff/views.py
@@ -1,7 +1,8 @@
 from django.shortcuts import render_to_response
 
+
 def debug(request):
     info = {
       'message': 'hi',
     }
-    return render_to_response('debug.html', { 'info': info })
+    return render_to_response('debug.html', {'info': info})
diff --git a/sapling/versionutils/merging/forms.py b/sapling/versionutils/merging/forms.py
index 5206d86..e6478a9 100644
--- a/sapling/versionutils/merging/forms.py
+++ b/sapling/versionutils/merging/forms.py
@@ -4,16 +4,17 @@ from django import forms
 from versionutils.versioning.utils import is_versioned
 from django.forms.models import model_to_dict
 
+
 class MergeModelForm(forms.ModelForm):
     """
     ModelForm subclass that detects editing conflicts.  For example, consider
     the following scenario:
-    
+
     User A obtains a form to edit model instance M
     User B obtains a form to edit the same instance
     User B makes some changes and submits the form.  M is updated.
     User A makes some changes and submits the form.  B's changes are lost.
-    
+
     MergeModelForm will check to see if anyone else has edited the associated
     model since the form was loaded.  If so, a ValidationError is raised with
     the provided conflict_message.
@@ -38,14 +39,14 @@ class MergeModelForm(forms.ModelForm):
     version_date = forms.CharField(widget=forms.HiddenInput(), required=False)
     conflict_warning = ('Warning: someone else made changes before you.  '
         'Please review the changes and save again.')
-    
+
     def __init__(self, *args, **kwargs):
         super(MergeModelForm, self).__init__(*args, **kwargs)
-        
+
         if 'instance' in kwargs:
             instance = kwargs['instance']
             self.initial['version_date'] = str(self.get_version_date(instance))
-    
+
     def get_version_date(self, instance):
         """
         Gets the datetime the instance was last modified.  This default
@@ -57,29 +58,31 @@ class MergeModelForm(forms.ModelForm):
         """
         if hasattr(self, 'version_date_field'):
             return getattr(instance, self.version_date_field)
-        
+
         # if using versioning, return most recent version date
         if is_versioned(instance):
             try:
                 return instance.history.most_recent().history_info.date
             except:
                 return ''
-            
+
         # no version_date_field specified, let's try to guess it
-        date_fields = [field for field in instance._meta.fields if isinstance(field, models.DateTimeField) and field.auto_now]
+        date_fields = [field for field in instance._meta.fields
+                        if isinstance(field, models.DateTimeField) and
+                           field.auto_now]
         if date_fields:
             return getattr(instance, date_fields[0].name) or ''
-        
+
         raise ValueError('MergeModelForm does not have a version_date_field')
-    
+
     def merge(self, yours, theirs, ancestor):
         """
         Merges the different versions of the object's fields in case of a
         conflict.  Override this to provide the actual merging.
-        
+
         Just like clean(), this should return a dictionary of cleaned fields
         that should be used.
-        
+
         Suggested use: override and try to merge the fields.  If the merge
         does not have any conflicts, return a dictionary of the merged fields.
         Otherwise, raise a helpful ValidationError, optionally setting
@@ -89,19 +92,20 @@ class MergeModelForm(forms.ModelForm):
         Attrs:
             yours: A dictionary of the current form's cleaned fields.
             theirs: A dictionary of the initial data from the instance.
-            ancestor: A dictionary of the historic ancestor's data, if available, or None
+            ancestor: A dictionary of the historic ancestor's data, if
+                available, or None
 
         Returns:
             A dictionary of cleaned and merged fields, similar to clean().
         """
         raise forms.ValidationError(self.conflict_warning)
-    
+
     def clean(self):
         """
-        Detects when the instance is newer than the one used to generate the form.
-        Calls merge() when there is a version conflict, and if there is still an
-        error, updates the version date in the form to give the user a chance
-        to save anyway.
+        Detects when the instance is newer than the one used to generate the
+        form.  Calls merge() when there is a version conflict, and if there is
+        still anerror, updates the version date in the form to give the user a
+        chance to save anyway.
 
         Returns
             cleaned_data.
@@ -110,13 +114,15 @@ class MergeModelForm(forms.ModelForm):
             ValidationError: When there's a conflict when calling merge().
         """
         current_version_date = str(self.get_version_date(self.instance))
-        if current_version_date != self.data['version_date']:
+        form_version_date = self.data['version_date']
+        if current_version_date != form_version_date:
             ancestor = None
-            if is_versioned(self.instance) and self.data['version_date']:
-                ancestor_model = self.instance.history.as_of(self.data['version_date'])
+            if is_versioned(self.instance) and form_version_date:
+                ancestor_model = self.instance.history.as_of(form_version_date)
                 ancestor = model_to_dict(ancestor_model)
             try:
-                self.cleaned_data = self.merge(self.cleaned_data, self.initial, ancestor)
+                self.cleaned_data = self.merge(self.cleaned_data, self.initial,
+                                               ancestor)
             except forms.ValidationError as e:
                 self.data = self.data.copy()
                 self.data['version_date'] = current_version_date
diff --git a/sapling/versionutils/versioning/constants.py b/sapling/versionutils/versioning/constants.py
index 1d21655..84b3a5f 100644
--- a/sapling/versionutils/versioning/constants.py
+++ b/sapling/versionutils/versioning/constants.py
@@ -1,7 +1,7 @@
 TYPE_ADDED = 0
-TYPE_UPDATED = 1 
+TYPE_UPDATED = 1
 TYPE_DELETED = 2
-TYPE_REVERTED = 3 
+TYPE_REVERTED = 3
 TYPE_REVERTED_ADDED = 4
 TYPE_REVERTED_DELETED = 5
 TYPE_CHOICES = (
diff --git a/sapling/versionutils/versioning/decorators.py b/sapling/versionutils/versioning/decorators.py
index 78e600c..7e1a351 100644
--- a/sapling/versionutils/versioning/decorators.py
+++ b/sapling/versionutils/versioning/decorators.py
@@ -1,5 +1,6 @@
 from functools import wraps
 
+
 def require_instance(historyManagerFunction):
     @wraps(historyManagerFunction)
     def _require_instance(*args, **kwargs):
@@ -7,5 +8,5 @@ def require_instance(historyManagerFunction):
         if not self.instance:
             raise TypeError("This method must be called via an instance of "
                             "the model rather than from the class.")
-        return historyManagerFunction(*args, **kwargs) 
+        return historyManagerFunction(*args, **kwargs)
     return _require_instance
diff --git a/sapling/versionutils/versioning/history_model_methods.py b/sapling/versionutils/versioning/history_model_methods.py
index aba8fe8..5cc6233 100644
--- a/sapling/versionutils/versioning/history_model_methods.py
+++ b/sapling/versionutils/versioning/history_model_methods.py
@@ -15,10 +15,12 @@ from django.db.models.sql.constants import LOOKUP_SEP
 from constants import *
 from utils import *
 
+
 def get_history_fields(self, model):
     """
     Returns a dictionary of the essential fields that will be added to the
-    historical record model, in addition to the ones returned by models.get_fields.
+    historical record model, in addition to the ones returned by
+    models.get_fields.
 
     Args:
         model: A model class.
@@ -49,9 +51,11 @@ def get_history_fields(self, model):
 
     return fields
 
+
 def type_to_verbose(m):
     return TYPE_CHOICES[m.history_info.type][1]
 
+
 def historical_record_init(m, *args, **kws):
     """
     This is the __init__ method of historical record instances.
@@ -61,6 +65,7 @@ def historical_record_init(m, *args, **kws):
     _wrap_reverse_lookups(m)
     return retval
 
+
 def _wrap_reverse_lookups(m):
     """
     Make reverse foreign key lookups return historical versions
@@ -83,7 +88,7 @@ def _wrap_reverse_lookups(m):
         if not unique_values:
             pk_att = m.history_info._object._meta.pk.attname
             pk_val = getattr(m.history_info._object, pk_att)
-            unique_values = {pk_att:pk_val}
+            unique_values = {pk_att: pk_val}
 
         # Construct something like {'b__email':'a@example.org', ...}
         # from the unique fields of the base model.
@@ -102,7 +107,7 @@ def _wrap_reverse_lookups(m):
         qs = qs.order_by(parent_pk_att).values(parent_pk_att).distinct()
         # then annotate the maximum history object id
         ids = qs.annotate(Max('history_id'))
-        history_ids = [ v['history_id__max'] for v in ids ]
+        history_ids = [v['history_id__max'] for v in ids]
         # return a QuerySet containing the proper history objects
         return parent_model.history.filter(history_id__in=history_ids)
 
@@ -116,7 +121,7 @@ def _wrap_reverse_lookups(m):
         if not unique_values:
             pk_att = m.history_info._object._meta.pk.attname
             pk_val = getattr(m.history_info._object, pk_att)
-            unique_values = {pk_att:pk_val}
+            unique_values = {pk_att: pk_val}
 
         # Construct something like {'b__email':'a@example.org', ...}
         # from the unique fields of the base model.
@@ -139,24 +144,25 @@ def _wrap_reverse_lookups(m):
     model_meta = m.history_info._object._meta
     related_objects = model_meta.get_all_related_objects()
     related_objects += model_meta.get_all_related_many_to_many_objects()
-    related_versioned = [ o for o in related_objects if is_versioned(o.model) ]
+    related_versioned = [o for o in related_objects if is_versioned(o.model)]
     for rel_o in related_versioned:
         # Set the accessor to a lazy lookup function that, when
         # accessed, looks up the proper related set.
         accessor = rel_o.get_accessor_name()
-        
+
         if isinstance(rel_o.field, models.OneToOneField):
             # OneToOneFields have a direct lookup (not a set).
-            _proper_reverse_lookup = partial(_reverse_attr_lookup, m, rel_o)
+            _reverse_lookup = partial(_reverse_attr_lookup, m, rel_o)
         else:
-            _proper_reverse_lookup = partial(_reverse_set_lookup, m, rel_o)
-        m._direct_lookup_fields[accessor] = SimpleLazyObject(_proper_reverse_lookup)
+            _reverse_lookup = partial(_reverse_set_lookup, m, rel_o)
+        m._direct_lookup_fields[accessor] = SimpleLazyObject(_reverse_lookup)
+
 
 def historical_record_getattribute(model, m, name):
     """
     We have to define our own __getattribute__ because otherwise there's
     no way to set our wrapped foreign key attributes.
-    
+
     If we try and set
     history_instance.att = SimpleLazyObject(_lookup_proper_fk_version)
     we'll get an error because Django does an isinstance() check on
@@ -174,6 +180,7 @@ def historical_record_getattribute(model, m, name):
         return direct_val
     return model.__getattribute__(m, name)
 
+
 def revert_to(hm, delete_newer_versions=False, **kws):
     """
     This is used on a *historical instance* - e.g. something you get
@@ -196,12 +203,12 @@ def revert_to(hm, delete_newer_versions=False, **kws):
     # kind of hm.history_info.get_instance() method. Providing
     # get_instance() would be a liability, though, because we want to
     # encourage interaction with the historical instance -- it does
-    # fancy foreignkey lookups, etc. 
+    # fancy foreignkey lookups, etc.
     m = hm.history_info._object
 
-    # If we simply grab hm.history_info._object we may hit a uniqueness exception
-    # if we save the model and it already exists.  This is because the pk of the
-    # model may have changed if it was deleted at some time.
+    # If we simply grab hm.history_info._object we may hit a uniqueness
+    # exception.  If we save the model and it already exists.  This is because
+    # the pk of the model may have changed if it was deleted at some time.
 
     # Get the current model instance if it exists and set the pk
     # accordingly.
@@ -226,6 +233,7 @@ def revert_to(hm, delete_newer_versions=False, **kws):
     else:
         m.save(reverted_to_version=hm, **kws)
 
+
 def version_number_of(hm):
     """
     Returns version number.
@@ -241,6 +249,7 @@ def version_number_of(hm):
         )
     return hm.history_info.instance._version_number
 
+
 class HistoricalMetaInfo(object):
     def __get__(self, instance, owner):
         self.instance = instance
@@ -267,6 +276,8 @@ class HistoricalObjectDescriptor(object):
         self.model = model
 
     def __get__(self, instance, owner):
-        values = (getattr(instance, f.attname) for f in self.model._meta.fields)
+        values = (getattr(instance, f.attname)
+                  for f in self.model._meta.fields
+                 )
         m = self.model(*values)
         return m
diff --git a/sapling/versionutils/versioning/manager.py b/sapling/versionutils/versioning/manager.py
index be93246..22db157 100644
--- a/sapling/versionutils/versioning/manager.py
+++ b/sapling/versionutils/versioning/manager.py
@@ -4,6 +4,7 @@ from django.db.models.query import QuerySet
 from utils import *
 from decorators import *
 
+
 class HistoryDescriptor(object):
     def __init__(self, model):
         self.model = model
@@ -24,9 +25,9 @@ class HistoricalMetaInfoQuerySet(QuerySet):
     """
     def filter(self, *args, **kws):
         rels = self.model._original_model._meta.get_all_related_objects()
-        versioned_vars = [ o.var_name for o in rels if is_versioned(o.model) ]
+        versioned_vars = [o.var_name for o in rels if is_versioned(o.model)]
         kws_new = {}
-        for k,v in kws.iteritems():
+        for k, v in kws.iteritems():
             k_new = k
             parts = k.split(models.sql.constants.LOOKUP_SEP)
             # Replace all instances of history_info__whatever with
@@ -58,7 +59,7 @@ class HistoryManager(models.Manager):
     def get_query_set(self):
         if self.instance is None:
             return HistoricalMetaInfoQuerySet(model=self.model)
-        
+
         # TODO: Explore using natural_key() here if it exists on the
         # model. One idea: SHA-1 an escaped, string form of the
         # natural_key() and store it as an indexed field in the
@@ -91,7 +92,7 @@ class HistoryManager(models.Manager):
             The most recent historical record instance.
 
         Raises:
-            DoesNotExist: Instance has no historical record. 
+            DoesNotExist: Instance has no historical record.
         """
         try:
             v = self.all()[0]
@@ -118,13 +119,13 @@ class HistoryManager(models.Manager):
         """
         try:
             if version and version > 0:
-                v = self.all().order_by('history_date')[version-1]
+                v = self.all().order_by('history_date')[version - 1]
             elif date:
                 v = self.filter(history_date__lte=date)[0]
         except IndexError:
             raise self.instance.DoesNotExist("%s hasn't been created yet." %
                     self.instance._meta.object_name)
-        
+
         return v
 
     class NoUniqueValuesError(Exception):
diff --git a/sapling/versionutils/versioning/middleware.py b/sapling/versionutils/versioning/middleware.py
index 827134a..7709dbf 100644
--- a/sapling/versionutils/versioning/middleware.py
+++ b/sapling/versionutils/versioning/middleware.py
@@ -8,6 +8,7 @@ IGNORE_USER_INFO_METHODS = (
     'GET', 'HEAD', 'OPTIONS', 'TRACE'
 )
 
+
 class AutoTrackUserInfoMiddleware(object):
     """
     Optional middleware to automatically add the current request user's
@@ -25,7 +26,9 @@ class AutoTrackUserInfoMiddleware(object):
         ip = request.META.get('REMOTE_ADDR', None)
 
         update_fields = functools.partial(self.update_fields, user, ip)
-        signals.pre_save.connect(update_fields, dispatch_uid=request, weak=False)
+        signals.pre_save.connect(
+            update_fields, dispatch_uid=request, weak=False
+        )
 
     def update_fields(self, user, ip, sender, instance, **kws):
         registry = FieldRegistry('user')
diff --git a/sapling/versionutils/versioning/models.py b/sapling/versionutils/versioning/models.py
index 17913d9..5bd9bf3 100644
--- a/sapling/versionutils/versioning/models.py
+++ b/sapling/versionutils/versioning/models.py
@@ -12,6 +12,7 @@ from constants import *
 from history_model_methods import get_history_fields
 import manager
 
+
 class TrackChanges(object):
     def contribute_to_class(self, cls, name):
         self.manager_name = name
@@ -159,7 +160,7 @@ class TrackChanges(object):
     def get_fields(self, model):
         """
         Creates copies of the model's original fields.
-        
+
         Returns:
             A dictionary mapping field name to copied field object.
         """
@@ -229,13 +230,14 @@ class TrackChanges(object):
                         # Fix related name conflict. We set this manually
                         # elsewhere so giving this a funky name isn't a
                         # problem.
-                        options['related_name'] = '%s_hist_set_2' % field.related.var_name
+                        options['related_name'] = ('%s_hist_set_2' %
+                            field.related.var_name)
                         hist_field = model_type('self', **options)
                     else:
                         # Make the field into a foreignkey pointed at the
                         # history model.
-                        fk_history_model = field.related.parent_model.history.model
-                        hist_field = model_type(fk_history_model, **options)
+                        fk_hist_obj = field.related.parent_model.history.model
+                        hist_field = model_type(fk_hist_obj, **options)
 
                     hist_field.name = field.name
                     hist_field.attname = field.attname
@@ -280,10 +282,10 @@ class TrackChanges(object):
             A dictionary of fields that will be added to the Meta inner
             class of the historical record model.
         """
-        meta = { 'ordering': ('-history_date',) }
+        meta = {'ordering': ('-history_date',)}
         for k in ALL_META_OPTIONS:
             if k in TrackChanges.META_TO_SKIP:
-                continue 
+                continue
             meta[k] = getattr(model._meta, k)
         return meta
 
@@ -322,7 +324,7 @@ class TrackChanges(object):
             if is_versioned(field.related.parent_model):
                 current_objs = getattr(instance, field.attname).all()
                 setattr(hist_instance, field.attname,
-                        [ o.history.most_recent() for o in current_objs ]
+                        [o.history.most_recent() for o in current_objs]
                 )
 
     def m2m_changed(self, attname, sender, instance, action, reverse,
@@ -335,8 +337,8 @@ class TrackChanges(object):
             attname: Attribute name of the m2m field on the base model.
         """
         if pk_set:
-            changed_ms = [ model.objects.get(pk=pk) for pk in pk_set ]
-            hist_changed_ms = [ m.history.most_recent() for m in changed_ms ]
+            changed_ms = [model.objects.get(pk=pk) for pk in pk_set]
+            hist_changed_ms = [m.history.most_recent() for m in changed_ms]
         hist_instance = instance.history.most_recent()
         hist_through = getattr(hist_instance, attname)
         if action == 'post_add':
@@ -357,7 +359,8 @@ class TrackChanges(object):
         attrs = {}
         for field in instance._meta.fields:
             if isinstance(field, models.fields.related.ForeignKey):
-                is_fk_to_self = field.related.parent_model == instance.__class__
+                is_fk_to_self = (field.related.parent_model ==
+                                 instance.__class__)
                 if is_versioned(field.related.parent_model) or is_fk_to_self:
                     # If the FK field is versioned, set it to the most
                     # recent version of that object.
@@ -367,10 +370,12 @@ class TrackChanges(object):
                     fk_hist_model = field.rel.to.history.model
                     fk_id_name = field.rel.field_name
                     fk_id_val = getattr(instance, field.attname)
-                    fk_objs = fk_hist_model.objects.filter(**{fk_id_name:fk_id_val})
+                    fk_objs = fk_hist_model.objects.filter(
+                        **{fk_id_name: fk_id_val}
+                    )
 
                     if fk_objs:
-                        attrs[field.name] = fk_objs[0] # most recent version
+                        attrs[field.name] = fk_objs[0]  # most recent version
                     else:
                         attrs[field.name] = None
                     continue
diff --git a/sapling/versionutils/versioning/storage.py b/sapling/versionutils/versioning/storage.py
index d6a072a..a5465c1 100644
--- a/sapling/versionutils/versioning/storage.py
+++ b/sapling/versionutils/versioning/storage.py
@@ -1,7 +1,7 @@
 """
-  * Right now we simply block delete() on FileFields.  Django's default behavior
-    is to never override a file -- it simply renames it whatever_2.txt. This
-    will work for us, for now.
+  * Right now we simply block delete() on FileFields.  Django's default
+    behavior is to never override a file -- it simply renames it
+    whatever_2.txt. This will work for us, for now.
 
       * This will work for our (localwiki) purposes because we'll probably
         have a separate model for the actual file and we can have a long
@@ -13,6 +13,7 @@
     this we can look at doing fancy things.
 """
 
+
 class FileStorageWrapper(object):
     """
     Prevents file deletion.
diff --git a/sapling/versionutils/versioning/tests/models.py b/sapling/versionutils/versioning/tests/models.py
index e84ef86..a583f2b 100644
--- a/sapling/versionutils/versioning/tests/models.py
+++ b/sapling/versionutils/versioning/tests/models.py
@@ -7,6 +7,7 @@ TODO: It would be cool to write a little thing to randomly generate
 model definitions for tests.
 """
 
+
 class M1(models.Model):
     a = models.CharField(max_length=200)
     b = models.CharField(max_length=200)
@@ -15,6 +16,7 @@ class M1(models.Model):
 
     history = TrackChanges()
 
+
 class M2(models.Model):
     a = models.CharField(max_length=200)
     b = models.TextField()
@@ -22,6 +24,7 @@ class M2(models.Model):
 
     history = TrackChanges()
 
+
 class M3BigInteger(models.Model):
     a = models.CharField(max_length=200)
     b = models.BooleanField(default=False)
@@ -29,23 +32,27 @@ class M3BigInteger(models.Model):
 
     history = TrackChanges()
 
+
 class M4Date(models.Model):
     a = models.DateTimeField(auto_now_add=True)
     b = models.DateField(auto_now_add=True)
 
     history = TrackChanges()
 
+
 class M5Decimal(models.Model):
     a = models.DecimalField(max_digits=19, decimal_places=3)
     b = models.DecimalField(max_digits=5, decimal_places=2)
 
     history = TrackChanges()
 
+
 class M6Email(models.Model):
     a = models.EmailField()
 
     history = TrackChanges()
 
+
 class M7Numbers(models.Model):
     a = models.FloatField()
     b = models.PositiveIntegerField()
@@ -54,64 +61,76 @@ class M7Numbers(models.Model):
 
     history = TrackChanges()
 
+
 class M8Time(models.Model):
     a = models.TimeField(auto_now_add=True)
 
     history = TrackChanges()
 
+
 class M9URL(models.Model):
     a = models.URLField(verify_exists=False)
 
     history = TrackChanges()
 
+
 class M10File(models.Model):
     a = models.FileField(upload_to='test_versioning_uploads')
 
     history = TrackChanges()
 
+
 class M11Image(models.Model):
     a = models.ImageField(upload_to='test_versioning_uploads')
 
     history = TrackChanges()
 
+
 class M12ForeignKey(models.Model):
     a = models.ForeignKey(M2)
     b = models.CharField(max_length=200)
 
     history = TrackChanges()
 
+
 class M12ForeignKeysRelatedSpecified(models.Model):
     a = models.ForeignKey(M2, related_name="g")
     b = models.CharField(max_length=200)
 
     history = TrackChanges()
 
+
 class M13ForeignKeySelf(models.Model):
     a = models.ForeignKey('self', null=True)
     b = models.CharField(max_length=200)
 
     history = TrackChanges()
 
+
 class Category(models.Model):
     a = models.CharField(max_length=200)
 
+
 class M14ManyToMany(models.Model):
     a = models.TextField()
     b = models.ManyToManyField(Category)
 
     history = TrackChanges()
 
+
 class LongerNameOfThing(models.Model):
     a = models.TextField()
 
     history = TrackChanges()
 
+
 class M15OneToOne(models.Model):
     a = models.CharField(max_length=200)
     b = models.OneToOneField(LongerNameOfThing)
 
     history = TrackChanges()
 
+
 class M16Unique(models.Model):
     a = models.CharField(max_length=200, unique=True)
     b = models.TextField()
@@ -119,65 +138,76 @@ class M16Unique(models.Model):
 
     history = TrackChanges()
 
+
 class M17ForeignKeyVersioned(models.Model):
     name = models.CharField(max_length=200)
     m2 = models.ForeignKey(M2)
 
     history = TrackChanges()
 
+
 class M17ForeignKeyVersionedCustom(models.Model):
     name = models.CharField(max_length=200)
     m2 = models.ForeignKey(M2)
 
     history = TrackChanges()
 
+
 class M18OneToOneFieldVersioned(models.Model):
     name = models.CharField(max_length=200)
     m2 = models.OneToOneField(M2)
 
     history = TrackChanges()
 
+
 class LameTag(models.Model):
     name = models.CharField(max_length=200)
 
     history = TrackChanges()
 
+
 class M19ManyToManyFieldVersioned(models.Model):
     a = models.TextField()
     tags = models.ManyToManyField(LameTag)
 
     history = TrackChanges()
 
+
 class CustomManager(models.Manager):
     def foo(self):
         print "bar"
 
+
 class M20CustomManager(models.Model):
     name = models.CharField(max_length=200)
     objects = models.Manager()
 
     myman = CustomManager()
-    
+
     history = TrackChanges()
 
+
 class M21CustomAttribute(models.Model):
     name = models.CharField(max_length=200)
     magic = "YES"
 
     history = TrackChanges()
 
+
 class M22ManyToManySelfVersioned(models.Model):
     a = models.TextField()
     tags = models.ManyToManyField('self')
 
     history = TrackChanges()
 
+
 class M23AutoNow(models.Model):
     a = models.DateTimeField(auto_now=True)
     b = models.CharField(max_length=200)
 
     history = TrackChanges()
 
+
 TEST_MODELS = [
     M1, M2, M3BigInteger, M4Date, M5Decimal, M6Email, M7Numbers,
     M8Time, M9URL, M10File, M11Image, M12ForeignKey, M13ForeignKeySelf,
diff --git a/sapling/versionutils/versioning/tests/tests.py b/sapling/versionutils/versioning/tests/tests.py
index a734eef..9d591fc 100644
--- a/sapling/versionutils/versioning/tests/tests.py
+++ b/sapling/versionutils/versioning/tests/tests.py
@@ -14,9 +14,10 @@ from models import *
 from versionutils.versioning.constants import *
 
 mgr = TestSettingsManager()
-INSTALLED_APPS=list(settings.INSTALLED_APPS)
+INSTALLED_APPS = list(settings.INSTALLED_APPS)
 INSTALLED_APPS.append('versionutils.versioning.tests')
-mgr.set(INSTALLED_APPS=INSTALLED_APPS) 
+mgr.set(INSTALLED_APPS=INSTALLED_APPS)
+
 
 class TrackChangesTest(TestCase):
     def _create_test_models(self):
@@ -67,7 +68,7 @@ class TrackChangesTest(TestCase):
         m.save()
         m.b.add(category)
         m.save()
-        
+
         thing = LongerNameOfThing(a="long name")
         thing.save()
         m = M15OneToOne(a="m15 yay!", b=thing)
@@ -92,7 +93,7 @@ class TrackChangesTest(TestCase):
         for M in self.test_models:
             objs += M.objects.all()
         return objs
-    
+
     def setUp(self):
         self._setup_file_environment()
         self.test_models = TEST_MODELS
@@ -121,7 +122,7 @@ class TrackChangesTest(TestCase):
         for m in self.all_objects():
             # saving should add a single history entry
             old_m, old_m_history_len = history_before[m]
-            self.assertEqual(len(m.history.all()), old_m_history_len+1)
+            self.assertEqual(len(m.history.all()), old_m_history_len + 1)
 
     def test_most_recent(self):
         m = M1.objects.get(a="A!")
@@ -135,13 +136,13 @@ class TrackChangesTest(TestCase):
         self.assertEqual(m.history.most_recent().d, m_old.d)
 
         recent_obj = m.history.most_recent().history_info._object
-        vals_recent = [ getattr(recent_obj, field)
-                        for field in recent_obj._meta.get_all_field_names()
+        vals_recent = [getattr(recent_obj, field)
+                       for field in recent_obj._meta.get_all_field_names()
         ]
-        vals_old = [ getattr(m_old, field)
-                     for field in m_old._meta.get_all_field_names()
+        vals_old = [getattr(m_old, field)
+                    for field in m_old._meta.get_all_field_names()
         ]
-        vals = [ getattr(m, field) for field in m._meta.get_all_field_names() ]
+        vals = [getattr(m, field) for field in m._meta.get_all_field_names()]
         self.assertEqual(
             vals_recent,
             vals
@@ -212,15 +213,16 @@ class TrackChangesTest(TestCase):
 
         # all the history entries should have the same unique field
         self.assertEqual([x.a for x in m.history.all()],
-                         ["What"]*len(m.history.all())
+                         ["What"] * len(m.history.all())
         )
         # and the history should be old_history_len+1 entries long
-        self.assertEqual(len(m.history.all()), old_history_len+1)
+        self.assertEqual(len(m.history.all()), old_history_len + 1)
 
     def test_deleted_object_nonunique(self):
         """
-        When we delete an object without any unique fields and then create a new object
-        with the same attributes, right afterward, we should see an entirely new history.
+        When we delete an object without any unique fields and then create a
+        new object with the same attributes, right afterward, we should see an
+        entirely new history.
         """
         m = M2(a="new m2!", b="text", c=54)
         m.save()
@@ -268,7 +270,7 @@ class TrackChangesTest(TestCase):
         m.save()
         for i in range(1, 100):
             # version numbers should line up with m.c value now
-            m.c = i+1
+            m.c = i + 1
             m.save()
 
         for i in range(1, 100):
@@ -299,7 +301,7 @@ class TrackChangesTest(TestCase):
 
         for i in range(1, 20):
             m.c = i
-            m.save() 
+            m.save()
 
         m_old = m.history.filter(c=4)[0]
         m_old.revert_to()
@@ -316,7 +318,7 @@ class TrackChangesTest(TestCase):
 
         for i in range(1, 20):
             m.c = i
-            m.save() 
+            m.save()
 
         # should be:
         # c=19, 18, 17, .. 5, 4, 3, 2 1, 0
@@ -362,7 +364,7 @@ class TrackChangesTest(TestCase):
 
         for i in range(1, 20):
             m.c = i
-            m.save() 
+            m.save()
 
         # should be:
         # c=19, 18, 17, .. 5, 4, 3, 2 1, 0
@@ -433,8 +435,9 @@ class TrackChangesTest(TestCase):
         mh.revert_to()
 
         self.assertEqual(len(M16Unique.objects.filter(a="Me me!")), 1)
-        self.assertEqual(M16Unique.objects.filter(a="Me me!")[0].b, "I am older")
-    
+        self.assertEqual(M16Unique.objects.filter(a="Me me!")[0].b,
+                         "I am older")
+
     def test_revert_to_deleted_version(self):
         # we test w/ an object w/ unique field in this case
         # non-unique re-creation doesn't make sense
@@ -470,12 +473,12 @@ class TrackChangesTest(TestCase):
         # entry.
         mh = M16Unique.history.filter(a="Gonna get", b="deleted", c=0)[0]
         self.assertEqual(mh.history_info.type, TYPE_REVERTED_DELETED)
-        
+
         # ====================================================================
         # Now with a revert when the object is also currently deleted
         # ====================================================================
 
-        m = M16Unique(a="About to get", b="really deleted", c=0) 
+        m = M16Unique(a="About to get", b="really deleted", c=0)
         m.save()
 
         m.delete()
@@ -538,7 +541,7 @@ class TrackChangesTest(TestCase):
         ###############################
         m2 = M2(a="i am m2!", b="yay!", c=1)
         m2.save()
-        
+
         m17 = M17ForeignKeyVersioned(name="yayfk!", m2=m2)
         m17.save()
 
@@ -572,8 +575,10 @@ class TrackChangesTest(TestCase):
         ###############################
         m2 = M2(a="i am m2 for onetoone!", b="onetoone yay!", c=1)
         m2.save()
-        
-        m18 = M18OneToOneFieldVersioned(name="i am the versioned thing!", m2=m2)
+
+        m18 = M18OneToOneFieldVersioned(
+            name="i am the versioned thing!", m2=m2
+        )
         m18.save()
 
         m18.name = m18.name + "!"
@@ -632,52 +637,52 @@ class TrackChangesTest(TestCase):
         #m12related = M12ForeignKeyRelatedSpecified()
 
     def test_fk_reverse_lookup(self):
-         # Reverse foreign key lookups on historical models should,
-         # if the parent model is versioned, return the related set
-         # as it was at the moment in time represented by the child
-         # model.
-         m2 = M2(a="relatedatest", b="relatedbtest", c=0)
-         m2.save()
-         m17 = M17ForeignKeyVersioned(name="relatedtest", m2=m2)
-         m17.save()
-
-         # because m2 was created before m17, the related set
-         # of the most recent historical version of m2 should be
-         # empty
-         m2_h = m2.history.most_recent()
-         self.assertEqual(len(m2_h.m17foreignkeyversioned_set.all()), 0)
-
-         m2.a += "!"
-         m2.save()
-         m17.name += "!"
-         m17.save()
-         # now the related set of the most recent entry should be the
-         # current m17
-         m2_h = m2.history.most_recent()
-         self.assertEqual(len(m2_h.m17foreignkeyversioned_set.all()), 1)
-         m17_h = m2_h.m17foreignkeyversioned_set.all()[0]
-         self.assertEqual(m17_h.name, "relatedtest")
-
-         m2.a += "!"
-         m2.save()
-
-         m2_h = m2.history.most_recent()
-         self.assertEqual(len(m2_h.m17foreignkeyversioned_set.all()), 1)
-         m17_h = m2_h.m17foreignkeyversioned_set.all()[0]
-         self.assertEqual(m17_h.name, "relatedtest!")
-
-         # let's have another model point at m2 
-         m17 = M17ForeignKeyVersioned(name="relatedtest2", m2=m2)
-         m17.save()
-
-         m2.a += "!"
-         m2.save()
-
-         m2_h = m2.history.most_recent()
-         related_set = m2_h.m17foreignkeyversioned_set
-         self.assertEqual(len(related_set.all()), 2)
-         self.assertEqual(len(related_set.filter(name="relatedtest2")), 1)
-         self.assertEqual(len(related_set.filter(name="relatedtest!")), 1)
+        # Reverse foreign key lookups on historical models should,
+        # if the parent model is versioned, return the related set
+        # as it was at the moment in time represented by the child
+        # model.
+        m2 = M2(a="relatedatest", b="relatedbtest", c=0)
+        m2.save()
+        m17 = M17ForeignKeyVersioned(name="relatedtest", m2=m2)
+        m17.save()
+
+        # because m2 was created before m17, the related set
+        # of the most recent historical version of m2 should be
+        # empty
+        m2_h = m2.history.most_recent()
+        self.assertEqual(len(m2_h.m17foreignkeyversioned_set.all()), 0)
+
+        m2.a += "!"
+        m2.save()
+        m17.name += "!"
+        m17.save()
+        # now the related set of the most recent entry should be the
+        # current m17
+        m2_h = m2.history.most_recent()
+        self.assertEqual(len(m2_h.m17foreignkeyversioned_set.all()), 1)
+        m17_h = m2_h.m17foreignkeyversioned_set.all()[0]
+        self.assertEqual(m17_h.name, "relatedtest")
+
+        m2.a += "!"
+        m2.save()
+
+        m2_h = m2.history.most_recent()
+        self.assertEqual(len(m2_h.m17foreignkeyversioned_set.all()), 1)
+        m17_h = m2_h.m17foreignkeyversioned_set.all()[0]
+        self.assertEqual(m17_h.name, "relatedtest!")
+
+        # let's have another model point at m2
+        m17 = M17ForeignKeyVersioned(name="relatedtest2", m2=m2)
+        m17.save()
+
+        m2.a += "!"
+        m2.save()
+
+        m2_h = m2.history.most_recent()
+        related_set = m2_h.m17foreignkeyversioned_set
+        self.assertEqual(len(related_set.all()), 2)
+        self.assertEqual(len(related_set.filter(name="relatedtest2")), 1)
+        self.assertEqual(len(related_set.filter(name="relatedtest!")), 1)
 
     @skipIf(settings.DATABASE_ENGINE == 'sqlite3',
             'See Django ticket #10164. Sqlite recycles primary keys')
@@ -709,7 +714,7 @@ class TrackChangesTest(TestCase):
 
         fk_version2 --------------
                                  |
-                                 v 
+                                 v
         fk_version1 ---------> m_version2
 
         then doing a reverse lookup in m.history should only
@@ -784,20 +789,20 @@ class TrackChangesTest(TestCase):
         m19 = M19ManyToManyFieldVersioned(a="best m19")
         m19.save()
         m19.tags.add(t1, t2)
-    
+
         t1.name += "!"
         t1.save()
         t2.name += "!"
         t2.save()
-    
+
         m19.a += "!"
         m19.save()
-    
+
         t1.name += "!"
         t1.save()
         t2.name += "!"
         t2.save()
-    
+
         # reverse set on these should be empty
         t1_h = t1.history.all()[2]
         t2_h = t2.history.all()[2]
@@ -805,7 +810,7 @@ class TrackChangesTest(TestCase):
         self.assertEqual(len(reverse_set.all()), 0)
         reverse_set = t2_h.m19manytomanyfieldversioned_set
         self.assertEqual(len(reverse_set.all()), 0)
-    
+
         # reverse set on these should be "best m19"
         t1_h = t1.history.all()[1]
         t2_h = t2.history.all()[1]
@@ -815,7 +820,7 @@ class TrackChangesTest(TestCase):
         reverse_set = t2_h.m19manytomanyfieldversioned_set
         self.assertEqual(len(reverse_set.all()), 1)
         self.assertEqual(reverse_set.all()[0].a, "best m19")
-    
+
         # reverse set on these should be "best m19!"
         t1_h = t1.history.all()[0]
         t2_h = t2.history.all()[0]
diff --git a/sapling/versionutils/versioning/tests/utils.py b/sapling/versionutils/versioning/tests/utils.py
index 490d9c2..c5238df 100644
--- a/sapling/versionutils/versioning/tests/utils.py
+++ b/sapling/versionutils/versioning/tests/utils.py
@@ -5,6 +5,7 @@ from django.test import TestCase
 
 NO_SETTING = ('!', None)
 
+
 class TestSettingsManager(object):
     """
     A class which can modify some Django settings temporarily for a
@@ -18,7 +19,7 @@ class TestSettingsManager(object):
         self._original_settings = {}
 
     def set(self, **kwargs):
-        for k,v in kwargs.iteritems():
+        for k, v in kwargs.iteritems():
             self._original_settings.setdefault(k, getattr(settings, k,
                                                           NO_SETTING))
             setattr(settings, k, v)
@@ -30,7 +31,7 @@ class TestSettingsManager(object):
         #call_command('syncdb', verbosity=0)
 
     def revert(self):
-        for k,v in self._original_settings.iteritems():
+        for k, v in self._original_settings.iteritems():
             if v == NO_SETTING:
                 delattr(settings, k)
             else:
@@ -52,6 +53,6 @@ class SettingsTestCase(TestCase):
     def __init__(self, *args, **kwargs):
         super(SettingsTestCase, self).__init__(*args, **kwargs)
         self.settings_manager = TestSettingsManager()
-    
+
     def tearDown(self):
         self.settings_manager.revert()
diff --git a/sapling/versionutils/versioning/utils.py b/sapling/versionutils/versioning/utils.py
index d064460..8625706 100644
--- a/sapling/versionutils/versioning/utils.py
+++ b/sapling/versionutils/versioning/utils.py
@@ -5,6 +5,7 @@ from django.db import models
 from django.conf import settings
 from django.db.models.sql.constants import LOOKUP_SEP
 
+
 def is_versioned(m):
     """
     Args:
@@ -15,15 +16,6 @@ def is_versioned(m):
     """
     return (getattr(m, '_history_manager_name', None) is not None)
 
-def is_historical_instance(m):
-    """
-    Is the provided instance a historical instance?
-
-    Args:
-        m: A model or historical model instance.
-    """
-    return (hasattr(p_h, '_original_model') and
-            is_versioned(p_h._original_model))
 
 def unique_lookup_values_for(m):
     """
@@ -57,9 +49,9 @@ def unique_lookup_values_for(m):
             related_pk = getattr(m, field.attname)
             k = "%s%sid" % (field.name, LOOKUP_SEP)
             v = related_pk
-            return { k : v }
+            return {k: v}
 
-        return { field.name: getattr(m, field.name) }
+        return {field.name: getattr(m, field.name)}
 
     if m._meta.unique_together:
         unique_fields = {}
@@ -84,11 +76,13 @@ def unique_lookup_values_for(m):
                 unique_fields[k] = getattr(m, k)
         return unique_fields
 
+
 def is_pk_recycle_a_problem(instance):
     if (settings.DATABASE_ENGINE == 'sqlite3' and
         not unique_lookup_values_for(instance)):
         return True
 
+
 def _related_objs_delete_passalong(m):
     """
     For all related objects, set _track_changes and _save_with
@@ -108,7 +102,7 @@ def _related_objs_delete_passalong(m):
     m._rel_objs_methods = {}
     # Get the related objects.
     related_objects = m._meta.get_all_related_objects()
-    related_versioned = [ o for o in related_objects if is_versioned(o.model) ]
+    related_versioned = [o for o in related_objects if is_versioned(o.model)]
     # Using related objs, build a dictionary mapping model class -> pks
     for rel_o in related_versioned:
         accessor = rel_o.get_accessor_name()
@@ -116,7 +110,7 @@ def _related_objs_delete_passalong(m):
             continue
         # OneToOneField means a single object.
         if rel_o.field.related.field.__class__ == models.OneToOneField:
-            objs = [ getattr(m, accessor) ]
+            objs = [getattr(m, accessor)]
         else:
             objs = getattr(m, accessor).all()
         for o in objs:
@@ -128,18 +122,22 @@ def _related_objs_delete_passalong(m):
     # one of the related objects
     for model in m._rel_objs_to_catch:
         ids_to_catch = m._rel_objs_to_catch[model]
-        _pass_on_arguments = partial(_set_arguments_for, m, model, ids_to_catch)
-        models.signals.pre_delete.connect(_pass_on_arguments, sender=model, weak=False)
+        _pass_on_arguments = partial(_set_arguments_for, m, model,
+            ids_to_catch)
+        models.signals.pre_delete.connect(_pass_on_arguments, sender=model,
+            weak=False)
         # Save the method so we can disconnect it
         m._rel_objs_methods[model] = _pass_on_arguments
-        
+
+
 def save_func(model_save):
     def save(m, *args, **kws):
         return save_with_arguments(model_save, m, *args, **kws)
     return save
 
-def save_with_arguments(model_save, m, force_insert=False, force_update=False, using=None,
-                        track_changes=True, **kws):
+
+def save_with_arguments(model_save, m, force_insert=False, force_update=False,
+                        using=None, track_changes=True, **kws):
     """
     A simple custom save() method on models with changes tracked.
 
@@ -149,19 +147,21 @@ def save_with_arguments(model_save, m, force_insert=False, force_update=False, u
     """
     m._track_changes = track_changes
     m._save_with = kws
-    
+
     return model_save(m, force_insert=force_insert,
                                       force_update=force_update,
                                       using=using,
     )
-    
+
+
 def delete_func(model_delete):
     def delete(*args, **kws):
         return delete_with_arguments(model_delete, *args, **kws)
     return delete
 
 
-def delete_with_arguments(model_delete, m, using=None, track_changes=True, **kws):
+def delete_with_arguments(model_delete, m, using=None,
+                          track_changes=True, **kws):
     """
     A simple custom delete() method on models with changes tracked.
 
